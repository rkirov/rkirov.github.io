<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Rado&#39;s Radical Reflections</title>
    <link>https://rkirov.github.io/posts/</link>
    <description>Recent content in Posts on Rado&#39;s Radical Reflections</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <managingEditor>rkirov@gmail.com</managingEditor>
    <webMaster>rkirov@gmail.com</webMaster>
    <lastBuildDate>Tue, 11 Nov 2025 20:18:26 -0800</lastBuildDate>
    <atom:link href="https://rkirov.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Is this JS function pure?</title>
      <link>https://rkirov.github.io/posts/pure/</link>
      <pubDate>Tue, 11 Nov 2025 20:18:26 -0800</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/pure/</guid>
      <description>&lt;h1 id=&#34;is-this-js-function-pure&#34;&gt;Is this JS function pure?&lt;/h1&gt;&#xA;&lt;p&gt;In 2019, as functional programming was making the last&#xA;inroads dethroning OOP, I kept hearing the mantra of&#xA;&amp;ldquo;just use pure functions&amp;rdquo; in JS. Something didn&amp;rsquo;t sit&#xA;right with me when talking very deterministically about&#xA;pure functions in a large unpure language like JS.&#xA;Especially, after seeing JS tooling perform&#xA;optimizations based on a pure annotation &lt;a href=&#34;https://webpack.js.org/guides/tree-shaking/&#34;&gt;(like webpack)&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;While everyone agrees &lt;code&gt;x =&amp;gt; x + 2&lt;/code&gt; is pure, I felt there&#xA;are a lot of subtle situations where disagreements might&#xA;arise. What is worse than terms with imprecise meaning&#xA;is terms with imprecise meaning where people using them&#xA;are not aware there is imprecision.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Why formalize mathematics - more than catching errors</title>
      <link>https://rkirov.github.io/posts/why_lean/</link>
      <pubDate>Thu, 16 Oct 2025 22:32:49 -0700</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/why_lean/</guid>
      <description>&lt;h1 id=&#34;why-formalize-mathematics---more-than-catching-errors&#34;&gt;Why formalize mathematics - more than catching errors&lt;/h1&gt;&#xA;&lt;p&gt;I read a good &lt;a href=&#34;https://lawrencecpaulson.github.io/2025/10/15/Proofs-trivial.html&#34;&gt;post&lt;/a&gt; by one of the authors of the Isabelle theorem prover, that got me thinking. The author, Lawrence Paulson, observed that most math proofs are trivial, but writing them (preferably with a proof assistant) is a worthwhile activity, for reasons similar to safety&#xA;checklists - &amp;ldquo;Not every obvious statement is true.&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;As I have been a bit obsessed with doing formalized mathematics, this got me thinking about why I am excited to spend&#xA;many hours recently writing formalized proofs in Lean for exercises from Tao&amp;rsquo;s &lt;a href=&#34;https://github.com/rkirov/analysis&#34;&gt;Real Analysis&lt;/a&gt; (along with this recent attempt to write a companion to &lt;a href=&#34;https://github.com/rkirov/category-theory-in-context-lean&#34;&gt;Riehl&amp;rsquo;s Category Theory In Context&lt;/a&gt;). On a very personal level, I just&#xA;like math, computers and puzzles, and writing Lean proofs feels like doing all three at once. But I do&#xA;believe formalization is important beyond nerd-snipping folks like me.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Learning Lean: Part 4</title>
      <link>https://rkirov.github.io/posts/lean4/</link>
      <pubDate>Sat, 20 Sep 2025 07:54:08 -0700</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/lean4/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s been 3 months since my previous post about learning Lean &lt;a href=&#34;https://rkirov.github.io/posts/lean3&#34;&gt;part 3&lt;/a&gt;, so it&amp;rsquo;s time to write another one. I have mostly continued to work through Tao&amp;rsquo;s Analysis book through his excellent &lt;a href=&#34;https://github.com/teorth/analysis&#34;&gt;companion&lt;/a&gt; - which means all proofs from the paper textbook are fully formalized in Lean, while examples and exercises are stated in Lean but left with a &lt;code&gt;sorry&lt;/code&gt; for me to fill in. Altogether the companions has close to 2000 sorries to fill-in.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Learning Lean: Part 3</title>
      <link>https://rkirov.github.io/posts/lean3/</link>
      <pubDate>Fri, 27 Jun 2025 22:30:30 -0700</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/lean3/</guid>
      <description>&lt;p&gt;I am continuing to learn Lean (see &lt;a href=&#34;https://rkirov.github.io/posts/lean1&#34;&gt;part 1&lt;/a&gt; and &lt;a href=&#34;https://rkirov.github.io/posts/lean2&#34;&gt;part 2&lt;/a&gt;). I lost some steam around March-April, but in the last&#xA;two months I picked it up again. In a way it was a nice spaced repetition for relearning some of the basics. This summary was supposed to be my notes from finishing the rest of &lt;a href=&#34;https://leanprover-community.github.io/mathematics_in_lean&#34;&gt;Mathematics in Lean&lt;/a&gt; and finishing chapters 2 and 3 of exercises from &lt;a href=&#34;https://github.com/teorth/analysis&#34;&gt;Terence Tao&amp;rsquo;s Analysis textbook&lt;/a&gt;, but also I couldn&amp;rsquo;t help also comment on the challenges and&#xA;opportunties I see in doing formal mathematics with Lean.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Thoughts on Signals in the JavaScript Ecosystem</title>
      <link>https://rkirov.github.io/posts/signals/</link>
      <pubDate>Sun, 30 Mar 2025 08:05:09 -0700</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/signals/</guid>
      <description>&lt;p&gt;Around 5-8 years ago when working on Angular and TypeScript rules in Bazel, I got&#xA;very interested in exploring the core ideas of incremental computation, which seemed&#xA;like the right way to abstractly (but still precisely) describe the similarities between&#xA;build systems and UI reactivity. As an aside, incremental dataflow is a third view into&#xA;the same concept, but I am least familiar with it.&lt;/p&gt;&#xA;&lt;p&gt;I wrote the following series of &lt;a href=&#34;https://rkirov.github.io/posts/incremental_computation/&#34;&gt;posts&lt;/a&gt;&#xA;to try to pull all the different threads together. It was useful for me to put something to paper,&#xA;but at the end I failed in painting a picture as clear as I wanted.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Learning Lean: Part 2</title>
      <link>https://rkirov.github.io/posts/lean2/</link>
      <pubDate>Sun, 02 Mar 2025 07:14:48 -0800</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/lean2/</guid>
      <description>&lt;p&gt;I am continuing to learn Lean (see &lt;a href=&#34;https://rkirov.github.io/posts/lean1&#34;&gt;part 1&lt;/a&gt;) by going through&#xA;&lt;a href=&#34;https://leanprover-community.github.io/mathematics_in_lean&#34;&gt;Mathematics in Lean&lt;/a&gt;. These are my notes as I just finished chapters one through five.&lt;/p&gt;&#xA;&lt;h2 id=&#34;mathematics-in-lean&#34;&gt;Mathematics in Lean&lt;/h2&gt;&#xA;&lt;p&gt;The online book is well-paced and well-written to connect with what an average student of mathematics already knows. The focus is on learning how to do basic mathematical proofs in Lean, and the underlying language is taught as needed for those goals, in comparison to Theorem Proving in Lean which is more of a language guide. For example, the fact that naturals&#xA;are constructed as an inductive type with zero and succ constructors is shown much after one is shown how to work with them. This is aligned with how a lot of mathematics is done before one discusses foundations in a typical mathematics curriculum, which might differ from a CS one.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Learning Lean: Part 1</title>
      <link>https://rkirov.github.io/posts/lean1/</link>
      <pubDate>Tue, 11 Feb 2025 22:26:55 -0800</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/lean1/</guid>
      <description>&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;&#xA;&lt;p&gt;I&amp;rsquo;ve been captivated by the recent movement to popularize mathematics formalization through the Lean theorem prover, and this year I&amp;rsquo;m diving deeper into learning it.&lt;/p&gt;&#xA;&lt;p&gt;For those unfamiliar with this revolution, I highly recommend watching &lt;a href=&#34;https://www.youtube.com/watch?v=SEID4XYFN7o&amp;amp;ab_channel=InternationalMathematicalUnion&#34;&gt;Kevin Buzzard&amp;rsquo;s talks on YouTube&lt;/a&gt; for an overview of why formal mathematics is generating such excitement in the mathematical community.&lt;/p&gt;&#xA;&lt;p&gt;The immediate benefits of formalization are well-documented: it helps catch errors in proofs and reduces the need for trust between collaborators since every step is mechanically verified. However, I believe there&amp;rsquo;s another compelling advantage that&amp;rsquo;s less frequently discussed: formalization enables a better separation of concerns in mathematical writing.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ticket to Ride: First Journey simulation authored with AI</title>
      <link>https://rkirov.github.io/posts/ticket/</link>
      <pubDate>Sat, 18 Jan 2025 11:52:17 -0800</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/ticket/</guid>
      <description>&lt;h2 id=&#34;ticket-to-ride-first-journey-simulation-authored-with-ai&#34;&gt;Ticket to Ride: First Journey simulation authored with AI&lt;/h2&gt;&#xA;&lt;p&gt;After playing &lt;a href=&#34;https://www.daysofwonder.com/ticket-to-ride/kids/first-journey/&#34;&gt;Ticket to Ride: First Journey&lt;/a&gt;&#xA;with my family recently, I got the urge&#xA;to analyze some statistical properties of the game.&#xA;This seemed like an excellent opportunity to experiment with Cursor AI and explore more automated approaches to coding. Here&amp;rsquo;s what I discovered.&lt;/p&gt;&#xA;&lt;h2 id=&#34;results&#34;&gt;Results&lt;/h2&gt;&#xA;&lt;p&gt;After a couple of hours the AI and I produced the following analyses:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;The 32 tickets in the game can be categorized by their optimal paths:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Puzzles2024</title>
      <link>https://rkirov.github.io/posts/puzzles2024/</link>
      <pubDate>Tue, 31 Dec 2024 11:42:13 -0800</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/puzzles2024/</guid>
      <description>&lt;h1 id=&#34;puzzle-games-of-2024&#34;&gt;Puzzle games of 2024&lt;/h1&gt;&#xA;&lt;p&gt;As the year draws to a close, I want to share my favorite puzzle games from 2024. This isn&amp;rsquo;t meant to be an exhaustive review or ranking of all puzzle games released this year, but rather a personal reflection on the games that captured my attention. If you&amp;rsquo;re new to the puzzle genre, I recommend starting with the &lt;a href=&#34;https://thinkygames.com/games/?query=&amp;amp;released=true&amp;amp;essential=true&amp;amp;sortBy=-releaseDate&#34;&gt;essential thinky games list&lt;/a&gt; - all of those titles are excellent.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Aoc2024</title>
      <link>https://rkirov.github.io/posts/aoc2024/</link>
      <pubDate>Wed, 25 Dec 2024 21:40:07 -0800</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/aoc2024/</guid>
      <description>&lt;h1 id=&#34;advent-of-code-2024-retro&#34;&gt;Advent of Code 2024 Retro&lt;/h1&gt;&#xA;&lt;p&gt;Advent of Code &lt;a href=&#34;https://adventofcode.com/&#34;&gt;AoC&lt;/a&gt; is an annual programming&#xA;competition that releases daily coding puzzles throughout December. For the past&#xA;four years, I&amp;rsquo;ve tackled these challenges from the West Coast, where the 9 PM&#xA;PST release time perfectly suits my schedule. While I compete for points on the&#xA;global leaderboard (with modest success), the real joy comes from the community&#xA;around it. Through Stripe&amp;rsquo;s solution-sharing Slack group, and the active&#xA;&lt;a href=&#34;https://www.reddit.com/r/adventofcode/&#34;&gt;r/adventofcode&lt;/a&gt; community, discussing&#xA;creative approaches to challenging problems adds an new dimension to my favorite&#xA;pastime - solving puzzles.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Incremental Computation (part 3)</title>
      <link>https://rkirov.github.io/posts/incremental_computation_3/</link>
      <pubDate>Tue, 19 May 2020 00:00:00 +0000</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/incremental_computation_3/</guid>
      <description>&lt;h2 id=&#34;why-typescript&#34;&gt;Why TypeScript?&lt;/h2&gt;&#xA;&lt;p&gt;Maybe you wondering why did I use TypeScript for this post. As it happens I&#xA;have been working in the frond-end community in the last 8 years. My interest&#xA;in incremental computation started by observing the similarities between some&#xA;of the work I have done inside Angular&amp;rsquo;s &amp;ldquo;change detection&amp;rdquo; algorithms, and&#xA;work I have done around integrating TypeScript&amp;rsquo;s compiler in &lt;a href=&#34;https://bazel.build/&#34;&gt;Google&amp;rsquo;s build&#xA;system&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;ui-programming&#34;&gt;UI programming&lt;/h2&gt;&#xA;&lt;p&gt;Why is incremental computation naturally appearing in UIs? As the user is&#xA;interacting with an UI they are providing new inputs. Usually, these inputs are&#xA;small compared with the initial input to the UI. On the other side the&#xA;producing the DOM is the quintessential &amp;ldquo;expensive&amp;rdquo; computation. If it redone&#xA;on each user input the UI will be unusable. So all UI frameworks attempt to&#xA;solve the incremental computation problem, struggling with the fact that JS has&#xA;no support for incremental computation. To make matters worse as we have seen&#xA;incrementality is easier in a functional language, but JS is not well suited to&#xA;that paradigm (which doesn&amp;rsquo;t stop people from trying).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Incremental Computation (part 2)</title>
      <link>https://rkirov.github.io/posts/incremental_computation_2/</link>
      <pubDate>Sun, 10 May 2020 00:00:00 +0000</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/incremental_computation_2/</guid>
      <description>&lt;p&gt;We have been talking about general computation, but so far our language was&#xA;very limited. We only used function calls, numbers, and simple variable&#xA;binding.&lt;/p&gt;&#xA;&lt;p&gt;We will slowly add more language primitives and see how to still have&#xA;full incrementality of the computation.&lt;/p&gt;&#xA;&lt;h2 id=&#34;conditional-statements&#34;&gt;Conditional statements&lt;/h2&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s add a single conditional statement first.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cond&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; : &lt;span style=&#34;color:#66d9ef&#34;&gt;y&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;What does it mean to make &lt;code&gt;cond&lt;/code&gt; incremental? Say&#xA;we compute the result first for some values of&#xA;&lt;code&gt;b&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Incremental Computation (part 1)</title>
      <link>https://rkirov.github.io/posts/incremental_computation/</link>
      <pubDate>Sun, 03 May 2020 00:00:00 +0000</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/incremental_computation/</guid>
      <description>&lt;p&gt;Incremental computation is a way of performing computations, with the&#xA;expectation of future changes in the inputs to the computiation. When those&#xA;changes occur the output can be updated efficiently, at minimum faster than&#xA;redoing the whole computation from scratch.&lt;/p&gt;&#xA;&lt;p&gt;This problem occurs in many programming domains - UI programming, data flow,&#xA;build systems, compilers, code editors. Likely you have seen it before, but&#xA;didn&amp;rsquo;t call it incremental computation. Despite its prevalence, it is rarely&#xA;viewed as a common computational paradigm. It is more often referred to as an&#xA;ad-hoc application of caching or memoization. In comparison, other&#xA;computational paradigms like concurrent, lazy, distributed computation have&#xA;better known nomenclature and techniques.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
