<!DOCTYPE html>
<html lang="en-us">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.69.2" />

<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr/amzrk2/favicons/favicon.ico" />


<title>Incremental Computation (Draft of part 1) - Subtly Different Semantics</title>

<meta name="author" content="" />
<meta name="description" content="Incremental computation is a way of performing computations, with the expectation of future changes in inputs. When those changes occur the new output can be obtained efficiently, at minimum avoiding redoing the whole computation.
Many programming environments deal with this problem - UI programming, dataflow, build systems, etc. Despite its prevalence, I find it is rarely viewer as a unified computational paradigm, as opposed to ad-hoc application of caching. In comparison, other computational paradigms like concurrent or distributed computating have better established nomenclature and techniques." />

<meta name="keywords" content="incremental computation" />


<meta property="og:title" content="Incremental Computation (Draft of part 1)" />
<meta property="og:description" content="Incremental computation is a way of performing computations, with the expectation of future changes in inputs. When those changes occur the new output can be obtained efficiently, at minimum avoiding redoing the whole computation.
Many programming environments deal with this problem - UI programming, dataflow, build systems, etc. Despite its prevalence, I find it is rarely viewer as a unified computational paradigm, as opposed to ad-hoc application of caching. In comparison, other computational paradigms like concurrent or distributed computating have better established nomenclature and techniques." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rkirov.github.io/posts/incremental_computation/" />
<meta property="article:published_time" content="2020-04-26T00:00:00-07:00" />
<meta property="article:modified_time" content="2020-04-26T00:00:00-07:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Incremental Computation (Draft of part 1)"/>
<meta name="twitter:description" content="Incremental computation is a way of performing computations, with the expectation of future changes in inputs. When those changes occur the new output can be obtained efficiently, at minimum avoiding redoing the whole computation.
Many programming environments deal with this problem - UI programming, dataflow, build systems, etc. Despite its prevalence, I find it is rarely viewer as a unified computational paradigm, as opposed to ad-hoc application of caching. In comparison, other computational paradigms like concurrent or distributed computating have better established nomenclature and techniques."/>






<link rel="stylesheet" href="https://rkirov.github.io/css/main.min.css" />




<script src="https://rkirov.github.io/js/jquery.min.js"></script>

<script src="https://rkirov.github.io/js/lazysizes.min.js"></script>

<link rel="stylesheet" href="https://rkirov.github.io/css/all.min.css" />









<body class="d-flex flex-column h-100">
    <header>
    
    <div class="container-lg clearfix">
        <div class="col-12 p-3">
            <a id="main-title" href="https://rkirov.github.io/">Subtly Different Semantics</a>
            <span id="sub-title"></span>
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-md-9 col-12 float-left" id="content">
                
<article>
    <h4 id="post-title">
        <a href="https://rkirov.github.io/posts/incremental_computation/">Incremental Computation (Draft of part 1)</a>
    </h4>
    <div id="post-meta">
        <span>
    <time datetime="2020-04-26 00:00:00 -0700 PDT">2020-04-26</time> |
</span>
<span>
    <span>2022 words</span> |
</span>
<span>
    
    
    <a href="https://rkirov.github.io//tags/incremental-computation/">incremental computation</a>
    
    
</span>
    </div>
    
    <div class="markdown-body" id="post-content">
        <p>Incremental computation is a way of performing computations, with the
expectation of future changes in inputs. When those changes occur the new
output can be obtained efficiently, at minimum avoiding redoing the
whole computation.</p>
<p>Many programming environments deal with this problem - UI programming,
dataflow, build systems, etc. Despite its prevalence, I find it is rarely
viewer as a unified computational paradigm, as opposed to ad-hoc application of
caching. In comparison, other computational paradigms like concurrent or
distributed computating have better established nomenclature and techniques.</p>
<p>The purpose of this text is to teach you what &lsquo;incremental computation&rsquo; is
(likely you have seen it before, but didn&rsquo;t use that term) and establish common
terminology for the basic approaches to the problem. I spend the last few years
surveying various academic and industry work that relate to incremental
computation, resulting in diverse pool of prior work. I hope this text guides
future work in the theory or applications of incremental computation.</p>
<h2 id="motivation">Motivation</h2>
<p>To introduce &lsquo;incremental computation&rsquo; I will start with intentionally limited
environment that only contains functions and immutable primitives (numbers).
If I jump straight into a full featured programming language will obscure the
core ideas. In a more formal setting this would be the lambda calculus, but I
will just use TypeScript and say away from higher-level constructs like arrays.
You can replace this with any run-of-the-mill programming language that has
closures.</p>
<p>Let&rsquo;s start with a very simple computation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">d</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
  <span style="color:#66d9ef">return</span> Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">y</span>);
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">computation</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">d</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
</code></pre></div><p>Incremental computation, ultimately, is concerned with the question how to most
effectively re-compute <code>d(x, y)</code> when some of the inputs have changed from <code>1</code>
and <code>2</code> to something else.</p>
<p>Say the new computation I would like to know is <code>d(1, 3)</code>. The new inputs
do not fully match the old ones, so a simple caching will not work as writen.</p>
<p>However, instead of giving up on caching, I can break down the computation
down to the basic operations: addition, multiplication and square root.</p>
<p>There are four core operations performed - two multiplications, one addition
and one <code>Math.sqrt</code>. I call the basic building blocks of an computation -
operations, but note that this is not standard. To spell it out using temporary
variables:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">op2</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">op3</span>);
</code></pre></div><p>Compare now with the version with the new inputs.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">op2</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">op3</span>);
</code></pre></div><p>For this toy example, the best incremental computation will reuse or skip <code>1 * 1</code> and then redo the other three operations with the new inputs. This can be
easily expressed in an abstract directed graph form:</p>
<pre><code>x -&gt; op1
y -&gt; op2
op1 -&gt; op3
op2 -&gt; op3
op3 -&gt; op4
</code></pre><p>The basic algorithm over the abstract computation graph is:</p>
<p>Basic Algorithm of Incremental Computation</p>
<ol>
<li>when at least one of the inputs of an operation has changed, redo the
computation to get new outputs.</li>
<li>repeat this or all nodes.</li>
</ol>
<p>This algorithm has no name as it is so simple. The complexity comes in how to
best build the computaiton graph, especially on top of general programming
languages which have no incremental primitives.</p>
<p>Also at this level you can already start to see the similarity with build
systems like &lsquo;make&rsquo;. In a way build systems are the simplest instances of
incremental computation.</p>
<p>The key questions around incremental computation at the abstract level of the
computation graph will be:</p>
<ul>
<li>how is this computation graph built?</li>
<li>how is the graph traversed. The Basic Algorithm in intentionally vague.</li>
<li>can it change while the program is running?</li>
<li>what if it has cycles?</li>
</ul>
<p>The questions that I view secondary to the core and not going to explore here are:</p>
<ul>
<li>who does the recomputation</li>
<li>can it be parallelized across different processes</li>
</ul>
<h2 id="incremental-computation-is-not-just-memoization">Incremental Computation is not &ldquo;just&rdquo; Memoization</h2>
<p>At this simple form incremental computation seems to be simply solved by
function memoization. Memoization is comparing the inputs of a function against
a cache of (inputs,output) pairs. If seen, the function body is skipped and
output used, otherwise the function body executes and the output is stored in
the cache.</p>
<p>Incremental computation usually is concerned with the recomputation against a
single past result, which would make it most fitting to use memoization with
a cache size of one. I view basic caching considerations - like size of cache,
least-frequently-used vs other strategies, orthogonal to the core problems
of incremental computation.</p>
<p>As previously discussed, we have to first rewrite the function to separate
the basic operations.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">d</span>(<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">number</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">number</span>) {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>;
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">y</span>;
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">op2</span>;
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">op3</span>);
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">op4</span>;
}
</code></pre></div><p>Now, we can memoize each inner operation along with the whole function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">memoAdd</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>(<span style="color:#a6e22e">add</span>, <span style="color:#e6db74">&#39;add&#39;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">memoSquare</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>(<span style="color:#a6e22e">square</span>, <span style="color:#e6db74">&#39;square&#39;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">memoSqrt</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>(Math.<span style="color:#a6e22e">sqrt</span>, <span style="color:#e6db74">&#39;sqrt&#39;</span>);

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">innerMemoD</span>(<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">number</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">number</span>) {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">x</span>);
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">y</span>);
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoAdd</span>(<span style="color:#a6e22e">op1</span>, <span style="color:#a6e22e">op2</span>);
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoSqrt</span>(<span style="color:#a6e22e">op3</span>);
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">op4</span>;
}
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">memoD</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>(<span style="color:#a6e22e">innerMemoD</span>, <span style="color:#e6db74">&#39;d&#39;</span>);
</code></pre></div><p>However, notice that while each operation is memoized - the flow through the
function is always the same <code>op1 -&gt; op2 -&gt; op3 -&gt; op4</code>, even if there some
sharing like computing <code>d(1, 3)</code> or <code>d(-1, 2)</code> after <code>d(1, 2)</code>.</p>
<p>We can produce the &lsquo;even-more-incremental&rsquo; program by adding some
&lsquo;check-if-changed-and-skip&rsquo; calls:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastOp1</span>: <span style="color:#66d9ef">null</span><span style="color:#f92672">|</span><span style="color:#66d9ef">number</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastOp2</span>: <span style="color:#66d9ef">null</span><span style="color:#f92672">|</span><span style="color:#66d9ef">number</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastOp3</span>: <span style="color:#66d9ef">null</span><span style="color:#f92672">|</span><span style="color:#66d9ef">number</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastOp4</span>: <span style="color:#66d9ef">null</span><span style="color:#f92672">|</span><span style="color:#66d9ef">number</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">skipCallsD</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">x</span>);

  <span style="color:#75715e">// why not &#39;if op === lastOp1 -&gt; skip&#39; here?
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">y</span>);

  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">op1</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">lastOp1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">lastOp2</span>) <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">lastOp4</span>;
  <span style="color:#a6e22e">lastOp1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op1</span>; <span style="color:#a6e22e">lastOp2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op2</span>;

  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoAdd</span>(<span style="color:#a6e22e">op1</span>, <span style="color:#a6e22e">op2</span>);

  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">op3</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">lastOp3</span>) <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">lastOp4</span>;
  <span style="color:#a6e22e">lastOp3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op3</span>;

  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoSqrt</span>(<span style="color:#a6e22e">op3</span>);
  <span style="color:#a6e22e">lastOp4</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op4</span>;

  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">op4</span>;
}
</code></pre></div><p>Notice that the structure of the checks matches the abstract computation graph.
We can&rsquo;t skip to the end if <code>op1</code> hasn&rsquo;t changed, because potentially <code>op2</code>.</p>
<p>Hopefully, at this point you are convinced that incremental computation problem
is not &lsquo;just&rsquo; memoization. Next I will show that it can be made to be just
memoization, but will require a bigger program transformation.</p>
<h2 id="incremental-computation-is-just-memoization">Incremental Computation is &ldquo;just&rdquo; Memoization</h2>
<p>We need to start with a bit of insight from the lambda calculus. Each variable
assignment <code>let x = &lt;init&gt;; &lt;rest&gt;</code> can be seen as <code>((x) =&gt; &lt;rest&gt;)(&lt;init&gt;)</code>,
giving us an opportunity to insert a memoization boundary on some new
functions that were not previously there.</p>
<p>The rewriten function now looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">insideOutD</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
  <span style="color:#66d9ef">return</span> ((<span style="color:#a6e22e">op1</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">op2</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> 
    ((<span style="color:#a6e22e">op3</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span>
      ((<span style="color:#a6e22e">op4</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span>
        <span style="color:#a6e22e">op4</span> 
      )(<span style="color:#a6e22e">memoSqrt</span>(<span style="color:#a6e22e">op3</span>))
    )(<span style="color:#a6e22e">memoAdd</span>(<span style="color:#a6e22e">op1</span>, <span style="color:#a6e22e">op2</span>))
  )(<span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">x</span>), <span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">y</span>))
}
</code></pre></div><p>Notice that we didn&rsquo;t use the similar looking rewriting, which would be more inline
with mechanically replacing each variable assignment operation.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">wrongD</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
  <span style="color:#66d9ef">return</span> ((<span style="color:#a6e22e">op1</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> 
    ((<span style="color:#a6e22e">op2</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span>
      ((<span style="color:#a6e22e">op3</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span>
        ((<span style="color:#a6e22e">op4</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span>
          <span style="color:#a6e22e">op4</span> 
        )(<span style="color:#a6e22e">memoSqrt</span>(<span style="color:#a6e22e">op3</span>))
      )(<span style="color:#a6e22e">memoAdd</span>(<span style="color:#a6e22e">op1</span>, <span style="color:#a6e22e">op2</span>))
    )(<span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">y</span>))
  )(<span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">x</span>))
}
</code></pre></div><p>It would have resulted in the correct original computation, but wrong incremental
computation. Turning this rewriting to an actual automated process would be an
interesting project.</p>
<p>Finally, we can extract the functions to run them throught memoization operation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fn1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>((<span style="color:#a6e22e">op1</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">op2</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">fn2</span>(<span style="color:#a6e22e">memoAdd</span>(<span style="color:#a6e22e">op1</span>, <span style="color:#a6e22e">op2</span>)));
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fn2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>((<span style="color:#a6e22e">op3</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">fn3</span>(<span style="color:#a6e22e">memoSqrt</span>(<span style="color:#a6e22e">op3</span>)));
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fn3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>((<span style="color:#a6e22e">op4</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">op4</span>);

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">superMemoDInner</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fn1</span>(<span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">x</span>), <span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">y</span>))
}
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">superMemoD</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>(<span style="color:#a6e22e">superMemoD</span>, <span style="color:#e6db74">&#39;d&#39;</span>);
</code></pre></div><p>While requiring a fancy program rewriting, to the point where the original
program is unrecognizable, this has a more aesteically pleasing property that
one can begin to imagine a principled way of adding incrementality instead of
manually inserting if-else statements.</p>
<p>Also having so many memoization calls is certainly an overkill in any practical
problem &ndash; we are memoizing an identity function at some point, which would be
faster to run &ndash; but the point of pushing a simple example to the extreme is to
see all the opportunities for incrementality. In practice, the incrementality
solution is often manually, inserted into an non-incremental program. Explroing
maximal incrementality over tiny program, shows all the techniques and ways in
which incrementality can be inserted.</p>
<p>But first we will need to introduce a key dimension of incremental computation, and
show another solution which is in a way the complete opposite.</p>
<h2 id="push-vs-pull-in-incremental-computation">Push vs Pull in Incremental Computation</h2>
<p>The memoization solution above there was a nice similarity re-computation, followed
exactly the same path as the original computation. Another way to say this is
that the re-computation was started and in the process it <em>pulled</em> the
updated inputs.</p>
<p>While very natural, there is an alternative approach. The new updates can themselves
trigger a recomputation.</p>
<p>Another terminology used is reactive vs interactive, but there is something called
&lsquo;push-based reactivity&rsquo; so I am coing to steer clear of these to avoid confusion.</p>
<p>To sumarize:</p>
<ul>
<li>classic computation (pull) - computatation <em>pulls</em> the updated inputs to
produce the desired outputs.</li>
<li>push-based incremental computation - the updated inputs <em>push</em> themselves
into the computation to produce the desired outputs.</li>
</ul>
<p>In our original example, a push-bassed version will look something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) {
    <span style="color:#a6e22e">p1</span>.<span style="color:#a6e22e">update</span>(<span style="color:#a6e22e">x</span>);
  }
};

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
    <span style="color:#a6e22e">p2</span>.<span style="color:#a6e22e">update</span>(<span style="color:#a6e22e">y</span>);
  }
};

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p1</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">last</span>: <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>,
  <span style="color:#a6e22e">update</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">last</span>) {
      <span style="color:#a6e22e">p3</span>.<span style="color:#a6e22e">updateArg1</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>);
    }
  }
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p2</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">last</span>: <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>,
  <span style="color:#a6e22e">update</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">last</span>) {
      <span style="color:#a6e22e">p3</span>.<span style="color:#a6e22e">updateArg2</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>);
    }
  }
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p3</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">arg1</span>: <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">number</span><span style="color:#f92672">|</span><span style="color:#66d9ef">null</span>,
  <span style="color:#a6e22e">arg2</span>: <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">number</span><span style="color:#f92672">|</span><span style="color:#66d9ef">null</span>,

  <span style="color:#a6e22e">updateArg1</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">arg1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>;
    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">arg2</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) <span style="color:#a6e22e">p4</span>.<span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">arg1</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">arg2</span>);
  },

  <span style="color:#a6e22e">updateArg2</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">arg2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>;
    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">arg1</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) <span style="color:#a6e22e">p4</span>.<span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">arg1</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">arg2</span>);
  },
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p4</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">last</span>: <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">number</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>,
  <span style="color:#a6e22e">update</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">last</span>) {
      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">x</span>);
      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;filal result:&#39;</span>, <span style="color:#a6e22e">result</span>);
    }
  }
}

<span style="color:#75715e">// computation
</span><span style="color:#75715e"></span><span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">set</span>(<span style="color:#ae81ff">1</span>);
<span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">set</span>(<span style="color:#ae81ff">1</span>);

<span style="color:#75715e">// re-computation
</span><span style="color:#75715e"></span><span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">set</span>(<span style="color:#ae81ff">2</span>);
</code></pre></div><p>Notice that in terms of operations this approach is just as efficient as the
pull-based one - one operation is reused and three others reevalutated.</p>
<p>When is a push-based vs pull-based incremental solution better? To be honest I
am not sure yet, would like to hear what do you think.</p>
<h2 id="connection-with-reactive--streaming-frameworks">Connection with Reactive / Streaming frameworks</h2>
<p>If you are familiar with reactive primitives like - streams, observables, etc,
you might have observed that the &lsquo;push-based&rsquo; solution, can be much simpler
using them. For example, here is the same solution, using rxjs observables.
To be fully equivalent it will need to add caching along each observable,
so that it doesn&rsquo;t reemit when the new value equals the previous one.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">of</span>, <span style="color:#a6e22e">combineLatest</span>, <span style="color:#a6e22e">Subject</span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;rxjs&#39;</span>;
<span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">map</span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;rxjs/operators&#39;</span>;

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Subject</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">number</span><span style="color:#f92672">&gt;</span>();
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Subject</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">number</span><span style="color:#f92672">&gt;</span>();

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>;
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>;
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">square</span>));
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">square</span>));
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">combineLatest</span>(<span style="color:#a6e22e">op1</span>, <span style="color:#a6e22e">op2</span>).<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">map</span>(([<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>]) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>))); 
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op3</span>.<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">map</span>(Math.<span style="color:#a6e22e">sqrt</span>));

<span style="color:#a6e22e">op4</span>.<span style="color:#a6e22e">subscribe</span>(<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>);

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;initial computation&#39;</span>);
<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">1</span>);
<span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">1</span>);

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;re-computation of with new y&#39;</span>);
<span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">next</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;re-computation of with new x&#39;</span>);
<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">2</span>);
</code></pre></div><p>The next challenge is to extend the toy computation model to a full blown
language that includes control flow and mutable object. We will begin with control flow.</p>
<h2 id="incremental-computation-and-control-flow">Incremental computation and control flow</h2>
<p>TODO - expand the original example. Discuss connection with &lsquo;applicative vs
monadic&rsquo; build systems.</p>
<h2 id="adaptive-computation">Adaptive computation</h2>
<p>Present <a href="https://github.com/rkirov/adapt-comp">https://github.com/rkirov/adapt-comp</a>.</p>
<h2 id="adding-mutable-objects-and-differential-programming">Adding mutable objects and differential programming</h2>
<p>TODO - present &ldquo;delta calculus&rdquo;.</p>
<h2 id="ui-programming">UI programming</h2>
<p>TODO - incremental programming in JS frameworks.</p>
<h2 id="conclusion">Conclusion</h2>
<p>TODO</p>
<h2 id="references">References</h2>
<ol>
<li>Mokhov, Mitchell, Jones, Build Systems à la Carte, Proc. ACM Program, 2018.</li>
<li>Magnus Carlsson. Monads for Incremental Computing. ICFP &lsquo;02 Proceedings of the seventh ACM SIGPLAN international conference on Functional programming</li>
<li>U. Acar, G. Blelloch, and R. Harper. Adaptive functional programming. In Principles of Programming Languages (POPL02), Portland, Oregon, January 2002. ACM</li>
<li>Conal Elliot, Functional Reactive Animation</li>
<li><a href="https://crates.io/crates/salsa">https://crates.io/crates/salsa</a></li>
<li><a href="https://github.com/TimelyDataflow/differential-dataflow">https://github.com/TimelyDataflow/differential-dataflow</a></li>
</ol>

    </div>
</article>

<div class="markdown-body" id="license">
    <blockquote>
        <p>Unless otherwise noted, the content of this site is licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (CC BY-NC-SA 4.0)</a>.</p>
    </blockquote>
</div>




            </div>
            
            <div class="col-md-3 col-12 float-left" id="sidebar">
                
<div id="widget-toc">
    <h5>TOC</h5>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#motivation">Motivation</a></li>
    <li><a href="#incremental-computation-is-not-just-memoization">Incremental Computation is not &ldquo;just&rdquo; Memoization</a></li>
    <li><a href="#incremental-computation-is-just-memoization">Incremental Computation is &ldquo;just&rdquo; Memoization</a></li>
    <li><a href="#push-vs-pull-in-incremental-computation">Push vs Pull in Incremental Computation</a></li>
    <li><a href="#connection-with-reactive--streaming-frameworks">Connection with Reactive / Streaming frameworks</a></li>
    <li><a href="#incremental-computation-and-control-flow">Incremental computation and control flow</a></li>
    <li><a href="#adaptive-computation">Adaptive computation</a></li>
    <li><a href="#adding-mutable-objects-and-differential-programming">Adding mutable objects and differential programming</a></li>
    <li><a href="#ui-programming">UI programming</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
</div>

<div id="widget-pages">
    <h5>Pages</h5>
    <ul>
        
        
        <li>
            <a href="/">Home</a>
        </li>
        
        <li>
            <a href="/about/">About</a>
        </li>
        
    </ul>
</div>
<div id="widget-tags">
    <h5>Tags</h5>
    <div>
        
        <span>
            <a href="https://rkirov.github.io/tags/incremental-computation/">incremental computation</a>
        </span>
        
    </div>
</div>
<div id="widget-links">
    <h5>Links</h5>
    <ul>
        
        <li>
            <a href="https://github.com/rkirov" target="_blank"><span>GitHub</span></a>
        </li>
        
        <li>
            <a href="https://twitter.com/radokirov" target="_blank"><span>Twitter</span></a>
        </li>
        
    </ul>
</div>

            </div>
            
            
        </div>
    </main>

    <footer>
    <div class="container-lg text-center">
        <p>&copy; 2020 <a href="https://rkirov.github.io/"></a> | Powered by <a href="https://github.com/amzrk2/hugo-theme-fuji/" target="_blank">Fuji</a> & <a href="https://gohugo.io/" target="_blank">Hugo</a> </p>
    </div>
</footer>
    




<script>
    $("#widget-toc a").click(function () {
        $("html, body").animate({
            scrollTop: $($(this).attr("href")).offset().top
        });
        return false;
    });
</script>



</body>

</html>