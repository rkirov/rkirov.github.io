<!DOCTYPE html>
<html lang="en">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.140.1">


<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/dsrkafuu/dsr-cdn-main@1/images/favicons/dsrca.ico" />



<title>Incremental Computation (part 3) - Subtly Different Semantics</title>




<meta name="keywords" content="incremental computation" />


<meta property="og:title" content="Incremental Computation (part 3)" />
<meta name="twitter:title" content="Incremental Computation (part 3)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rkirov.github.io/posts/incremental_computation_3/" /><meta property="og:description" content="Why TypeScript?
Maybe you wondering why did I use TypeScript for this post. As it happens I
have been working in the frond-end community in the last 8 years. My interest
in incremental computation started by observing the similarities between some
of the work I have done inside Angular&rsquo;s &ldquo;change detection&rdquo; algorithms, and
work I have done around integrating TypeScript&rsquo;s compiler in (Google&rsquo;s build
system)[https://bazel.build/].
UI programming
Why is incremental computation naturally appearing in UIs? As the user is
interacting with an UI they are providing new inputs. Usually, these inputs are
small compared with the initial input to the UI. On the other side the
producing the DOM is the quintessential &ldquo;expensive&rdquo; computation. If it redone
on each user input the UI will be unusable. So all UI frameworks attempt to
solve the incremental computation problem, struggling with the fact that JS has
no support for incremental computation. To make matters worse as we have seen
incrementality is easier in a functional language, but JS is not well suited to
that paradigm (which doesn&rsquo;t stop people from trying)." />
<meta name="twitter:description" content="Why TypeScript?
Maybe you wondering why did I use TypeScript for this post. As it happens I
have been working in the frond-end community in the last 8 years. My interest
in incremental computation started by observing the similarities between some
of the work I have done inside Angular&rsquo;s &ldquo;change detection&rdquo; algorithms, and
work I have done around integrating TypeScript&rsquo;s compiler in (Google&rsquo;s build
system)[https://bazel.build/].
UI programming
Why is incremental computation naturally appearing in UIs? As the user is
interacting with an UI they are providing new inputs. Usually, these inputs are
small compared with the initial input to the UI. On the other side the
producing the DOM is the quintessential &ldquo;expensive&rdquo; computation. If it redone
on each user input the UI will be unusable. So all UI frameworks attempt to
solve the incremental computation problem, struggling with the fact that JS has
no support for incremental computation. To make matters worse as we have seen
incrementality is easier in a functional language, but JS is not well suited to
that paradigm (which doesn&rsquo;t stop people from trying)." /><meta name="twitter:card" content="summary" /><meta property="article:published_time" content="2020-05-19T00:00:00+00:00" /><meta property="article:modified_time" content="2020-05-19T00:00:00+00:00" />


<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>




<link rel="stylesheet" href="https://rkirov.github.io/assets/css/fuji.min.b4a21b5d3eb1d0a51297e31230a65fc25e387843e45ec3a2d9176cd8d163c216d99b9b13a618b28f537c3b559ec8a408183b0fbfad48daddb9befa7d3ef90eed.css" integrity="sha512-tKIbXT6x0KUSl&#43;MSMKZfwl44eEPkXsOi2Rds2NFjwhbZm5sTphiyj1N8O1WeyKQIGDsPv61I2t25vvp9PvkO7Q==" />








</head>

<body
  data-theme="auto"
  data-theme-auto='false'
  >
    <script data-cfasync="false">
  
  var fujiThemeData = localStorage.getItem('fuji_data-theme');
  
  if (!fujiThemeData) {
    localStorage.setItem('fuji_data-theme', 'auto');
  } else {
    
    if (fujiThemeData !== 'auto') {
      document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
    }
  }
</script>

    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://rkirov.github.io/">Subtly Different Semantics</a>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://rkirov.github.io/posts/incremental_computation_3/">Incremental Computation (part 3)</a>
    </h2>
    <div class="post-item post-meta">
        <span><i class="iconfont icon-today-sharp"></i>&nbsp;2020-05-19</span>



<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href="/tags/incremental-computation">incremental computation</a>&nbsp;</span>

    </div>
    
    <div class="post-content markdown-body">
        <h2 id="why-typescript">Why TypeScript?</h2>
<p>Maybe you wondering why did I use TypeScript for this post. As it happens I
have been working in the frond-end community in the last 8 years. My interest
in incremental computation started by observing the similarities between some
of the work I have done inside Angular&rsquo;s &ldquo;change detection&rdquo; algorithms, and
work I have done around integrating TypeScript&rsquo;s compiler in (Google&rsquo;s build
system)[https://bazel.build/].</p>
<h2 id="ui-programming">UI programming</h2>
<p>Why is incremental computation naturally appearing in UIs? As the user is
interacting with an UI they are providing new inputs. Usually, these inputs are
small compared with the initial input to the UI. On the other side the
producing the DOM is the quintessential &ldquo;expensive&rdquo; computation. If it redone
on each user input the UI will be unusable. So all UI frameworks attempt to
solve the incremental computation problem, struggling with the fact that JS has
no support for incremental computation. To make matters worse as we have seen
incrementality is easier in a functional language, but JS is not well suited to
that paradigm (which doesn&rsquo;t stop people from trying).</p>
<p>The following is a quick list of the popular JS frameworks and how much
incremental computation they support or not:</p>
<ul>
<li>Classic React - Incrementality is relegated to purely at the VDOM to DOM
layer. This is similar to the classic on-line combinatorial algorithms. When
the data structure is fixed a custom solution can be implemented, without the
need for a general incremental computation framework. The user can treat the
system as completely non-incremental. This is definitely a simpler conceptual
model, but it is not the most efficient thing to do. The lack of
incrementality outside VDOM to DOM was noticed as performance issue by the
community. <a href="https://gist.github.com/sw-yx/9bf1fad03185613a4c19ef5352d90a09" target="_blank">React is not
reactive</a> is
a great summary of the upside and downsides to moving to a fully reactive
(read incremental) react.</li>
<li>React Hooks - Moving from ad-hoc solutions like manually writing
<code>shouldUpdate</code> to hooks like <code>useMemo</code>, <code>useEffect</code> which have better
incrementality support.  However, as we have seen so far full incremental
computation is more intricate than just memoizing. AFAIKT, there is no
support for dynamic tracking of dependencies with the built-in hooks. The
classic expression <code>c ? x : y</code> will have to be written as dependent on <code>[c, x, y]</code> in <code>useEffect</code>.</li>
<li>Angular - While React recomputes the DOM (VDOM to be more precise) directly,
Angular&rsquo;s recomputation of the DOM can be seen as a reverse mode where the
template is computed starting from its dynamic parts - the template
expressions which pull all the needed data. This computation is also not
incremental. Because Angular does ship with RxJS interested users are
exploring adding more incrementality, because as we saw it can be used as
building block for incrementality -
<a href="https://ngrx.io/guide/component" target="_blank">ngrx/component</a>.  Separately, Angular
supports diffing of arrays for <code>ng-for</code>, which can be seen as an ad-hoc
incremental computation of type <code>T[] =&gt; Node[]</code>.</li>
<li>Vue.js - Similar to Angular supports diffing for arrays and propagating
diffs, but no other finer grained incrementality.</li>
<li>Lit HTML - Does not have any built-in incrementality, but because the
computation is directly expressed in terms on the value inputs, recomputation
is simpler.</li>
<li>Cycle.js - the closest to a full solution for incrementity. The model data is
carried through RxJS observables, which as we have seen naturally allows for
incremental computation.</li>
<li>Svelte - With the introduction of the <code>$:</code> reactivity marker Svelte is adding
language level incrementality (called reactivity by the authors) to JS.
Instead of embedded DSL fashion like cycle.js, which makes the incremental
objects reified and visible to the user, in svelte they are generated allowing
one to write in what seems like a incremental version of JavaScript. That
said Svelte does not support dynamic incremental computation. This can
be seen by the usual test of <code>$: a ? b : c</code> which will be updated on both
<code>b</code> and <code>c</code> in Svelte.</li>
</ul>
<p>As this very quick survey shows in the modern JS framework space, there is
general attempt to find the most ergonomic and practical way to expose some
sort of incremental computation on top of an imperative language - JavaScript.
And to be absolutely clear this is not a comparison of better vs worst of JS
framework. The more incremental solutions can turn out to be unergonomic or add
too high of an overhead (similar to parallel computation). This was merely an
attempt to put them on equal grounding against a common model of ideal (and
likely impractical) incrementity, so that we can understand the tradeoffs and
the landscape better.</p>
<p>If one moves further from native JS, an into transpiled-to-JS land, supporting
full incremental computation becomes much more manageable as <a href="[https://blog.janestreet.com/self-adjusting-dom-and-diffable-data/">this blog by
Yaron
Minsky</a> and
<a href="https://www.youtube.com/watch?v=R3xX37RGJKE" target="_blank">talk</a> show.</p>
<h2 id="pragmatics">Pragmatics</h2>
<p>Given what you have seen so far, maybe you are excited to start using
incremental computation in your project. I have to absolutely honest, if it
wasn&rsquo;t very clear, there are too many unknowns around the pragmatics of
incremental computation to recommend it (at least in the JS space). This is
an non-exhaustive list of pragmatic questions around incremental computation:</p>
<ul>
<li>what is the runtime overhead of creating closures around each part of the
computation.</li>
<li>how to not run in to issues around garbage collection and memory leaks around
holding the incremental computation closures.</li>
<li>using native data-structures and algorithms with differential solutions, vs
pure incremental computation.</li>
<li>in language like JS that has mutation, how does one prevent abuse of the
core invariants (all reads have to go through <code>read</code> method etc).</li>
<li>is it better to support incremental computation as a DSL on top of an
existing language vs writing in a simpler looking language that is natively
incremental (transpiling to the code we have seen).</li>
</ul>
<p>In any case, these can lead to some great conversations, so if you think you
have an answer reach out.</p>
<h2 id="conclusion">Conclusion</h2>
<p>So what was this all about? To borrow a lovely analogy from Edward Kmett&rsquo;s talk
<a href="https://www.youtube.com/watch?v=j0XmixCsWjs" target="_blank">Stop threading water - Learning to
learn</a> - research and development
(or academia and industry) are stuck in maze trying to reach each other.
Research has some lovely solutions, but doesn&rsquo;t understand well the real-world
problems, while development has excellent grasp on the real-world problems,
but lacks the principled thought-through solutions. Left on their own devices
each tries to traverse the maze of ideas to get through the other end.</p>
<p>But if they collaborate they can meet in the middle and shorten the search.
The picture that Kmett uses in his talk is something like this.</p>
<p><img class="img-zoomable" src="/maze.png" alt="The maze" />
</p>
<p>Looking around the space of UI programming for the web, I think we are getting
close to the meeting point of the research of incremental computation and the
industry need for efficiently updating UIs.</p>
<p>My hope for this blog post is to shine some light on both loose ends so that
folks on both sides can be more efficient in connecting the problems and the
solutions.</p>
<h2 id="references">References</h2>
<ol>
<li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf" target="_blank">Mokhov, Mitchell, Jones, Build Systems à la Carte, Proc. ACM Program, 2018.</a></li>
<li><a href="https://dl.acm.org/doi/abs/10.1145/581478.581482" target="_blank">Magnus Carlsson. Monads for Incremental Computing. ICFP &lsquo;02 Proceedings of the seventh ACM SIGPLAN international conference on Functional programming</a></li>
<li><a href="https://www.cs.cmu.edu/~guyb/papers/popl02.pdf" target="_blank">U. Acar, G. Blelloch, and R. Harper. Adaptive functional programming. In Principles of Programming Languages (POPL02), Portland, Oregon, January 2002. ACM</a></li>
<li><a href="https://crates.io/crates/salsa" target="_blank">Rust Salsa framework</a></li>
<li><a href="https://www.cs.princeton.edu/~appel/papers/ssafun.pdf" target="_blank">SSA is Functional Programming</a></li>
<li><a href="https://www.jantar.org/papers/chakravarty03perspective.pdf" target="_blank">https://www.jantar.org/papers/chakravarty03perspective.pdf</a></li>
<li><a href="https://blog.janestreet.com/introducing-incremental/" target="_blank">Introducing Incremental</a></li>
<li><a href="https://github.com/chriseidhof/incremental-simplified" target="_blank">Incremental computation in Swift</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.32.1230&amp;rep=rep1&amp;type=pdf" target="_blank">Analysis and Caching of Dependencies</a></li>
<li><a href="https://arxiv.org/abs/1312.0658" target="_blank">A Theory of Changes for Higher-Order Languages - Incrementalizing λ-Calculi by Static Differentiation</a></li>
<li><a href="https://arxiv.org/pdf/1503.07792.pdf" target="_blank">Incremental Computation with Names</a></li>
<li><a href="https://www.youtube.com/watch?v=j0XmixCsWjs" target="_blank">Edward Kmett - &ldquo;Stop Threading Water: Learning to Learn&rdquo;</a></li>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/75277.75305?download=true" target="_blank">Incremental Computation via Function Caching</a></li>
<li><a href="https://arxiv.org/pdf/1808.07826.pdf" target="_blank">Typed incremental computation with names</a></li>
</ol>

    </div>
</article>




            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
            <li>
                <a href="https://github.com/rkirov" target="_blank"><span>GitHub</span></a>
            </li>
            
            <li>
                <a href="https://twitter.com/radokirov" target="_blank"><span>Twitter</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tags</h3>
        <div>
            
            <span>
                <a href="/tags/incremental-computation/">Incremental Computation</a>
            </span>
            
        </div>
    </div>
    <div class="sidebar-item sidebar-toc">
        <h3>Table of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#why-typescript">Why TypeScript?</a></li>
    <li><a href="#ui-programming">UI programming</a></li>
    <li><a href="#pragmatics">Pragmatics</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
    <li><a href="#references">References</a></li>
  </ul>
</nav></div>
</aside>

        </div>
        <div class="btn">
    <div class="btn-menu" id="btn-menu">
        <i class="iconfont icon-grid-sharp"></i>
    </div>
    <div class="btn-toggle-mode">
        <i class="iconfont icon-contrast-sharp"></i>
    </div>
    <div class="btn-scroll-top">
        <i class="iconfont icon-chevron-up-circle-sharp"></i>
    </div>
</div>
<aside class="sidebar-mobile" style="display: none;">
  <div class="sidebar-wrapper">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
            <li>
                <a href="https://github.com/rkirov" target="_blank"><span>GitHub</span></a>
            </li>
            
            <li>
                <a href="https://twitter.com/radokirov" target="_blank"><span>Twitter</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tags</h3>
        <div>
            
            <span>
                <a href="/tags/incremental-computation/">Incremental Computation</a>
            </span>
            
        </div>
    </div>
    
    
    
    
  </div>
</aside>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            
            <span>&copy; 2024
                <a href="https://rkirov.github.io/"></a>
                
                | Powered by <a href="https://github.com/dsrkafuu/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> &amp; <a href="https://gohugo.io/"
                                                    target="_blank">Hugo</a> 
            </span>
        </div>
    </div>
</footer>

    
<script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js" integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js" integrity="sha512-LCKPTo0gtJ74zCNMbWw04ltmujpzSR4oW+fgN+Y1YclhM5ZrHCZQAJE4quEodcI/G122sRhSGU2BsSRUZ2Gu3w==" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-GP4x8UWxWyh4BMbyJGOGneiTbkrWEF5izsVJByzVLodP8CuJH/n936+yQDMJJrOPUHLgyPbLiGw2rXmdvGdXHA==" crossorigin="anonymous"></script>



<script defer src="/assets/js/fuji.min.645f1123be695831f419ab54c1bcba327325895c740014006e57070d4f3e5d6b553e929c4b46f40ea707249e9c7f7c2a446d32a39ce7319f80a34525586a8e0f.js" integrity="sha512-ZF8RI75pWDH0GatUwby6MnMliVx0ABQAblcHDU8&#43;XWtVPpKcS0b0DqcHJJ6cf3wqRG0yo5znMZ&#43;Ao0UlWGqODw=="></script>



</body>

</html>
