<!DOCTYPE html>
<html lang="en-us">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.70.0" />

<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr/amzrk2/favicons/favicon.ico" />


<title>Incremental Computation (Draft of part 2) - Subtly Different Semantics</title>

<meta name="author" content="" />
<meta name="description" content="Incremental computation (part 2) We have been talking about general computation, but so far our language was very limited. We only used function calls, numbers, and simple variable binding.
We will slowly add more language primitives and see how to still have incrementality of the computation. First is conditional statements.
Conditional statements Let&rsquo;s add a single conditional statement first.
function cond(b: boolean, x: number, y: number) { return b ? x * x : y * y; } What does it mean to make cond incremental?" />

<meta name="keywords" content="incremental computation" />


<meta property="og:title" content="Incremental Computation (Draft of part 2)" />
<meta property="og:description" content="Incremental computation (part 2) We have been talking about general computation, but so far our language was very limited. We only used function calls, numbers, and simple variable binding.
We will slowly add more language primitives and see how to still have incrementality of the computation. First is conditional statements.
Conditional statements Let&rsquo;s add a single conditional statement first.
function cond(b: boolean, x: number, y: number) { return b ? x * x : y * y; } What does it mean to make cond incremental?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rkirov.github.io/posts/incremental_computation_2/" />
<meta property="article:published_time" content="2020-05-10T00:00:00-07:00" />
<meta property="article:modified_time" content="2020-05-10T00:00:00-07:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Incremental Computation (Draft of part 2)"/>
<meta name="twitter:description" content="Incremental computation (part 2) We have been talking about general computation, but so far our language was very limited. We only used function calls, numbers, and simple variable binding.
We will slowly add more language primitives and see how to still have incrementality of the computation. First is conditional statements.
Conditional statements Let&rsquo;s add a single conditional statement first.
function cond(b: boolean, x: number, y: number) { return b ? x * x : y * y; } What does it mean to make cond incremental?"/>






<link rel="stylesheet" href="https://rkirov.github.io/css/main.min.css" />




<script src="https://rkirov.github.io/js/jquery.min.js"></script>

<script src="https://rkirov.github.io/js/lazysizes.min.js"></script>

<link rel="stylesheet" href="https://rkirov.github.io/css/all.min.css" />









<body class="d-flex flex-column h-100">
    <header>
    
    <div class="container-lg clearfix">
        <div class="col-12 p-3">
            <a id="main-title" href="https://rkirov.github.io/">Subtly Different Semantics</a>
            <span id="sub-title"></span>
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-md-9 col-12 float-left" id="content">
                
<article>
    <h4 id="post-title">
        <a href="https://rkirov.github.io/posts/incremental_computation_2/">Incremental Computation (Draft of part 2)</a>
    </h4>
    <div id="post-meta">
        <span>
    <time datetime="2020-05-10 00:00:00 -0700 PDT">2020-05-10</time> |
</span>
<span>
    <span>1764 words</span> |
</span>
<span>
    
    
    <a href="https://rkirov.github.io//tags/incremental-computation/">incremental computation</a>
    
    
</span>
    </div>
    
    <div class="markdown-body" id="post-content">
        <h2 id="incremental-computation-part-2">Incremental computation (part 2)</h2>
<p>We have been talking about general computation, but so far our language was
very limited. We only used function calls, numbers, and simple variable
binding.</p>
<p>We will slowly add more language primitives and see how to still have
incrementality of the computation. First is conditional statements.</p>
<h2 id="conditional-statements">Conditional statements</h2>
<p>Let&rsquo;s add a single conditional statement first.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">cond</span>(<span style="color:#a6e22e">b</span>: <span style="color:#66d9ef">boolean</span>, <span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span> : <span style="color:#66d9ef">y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">y</span>; 
}
</code></pre></div><p>What does it mean to make <code>cond</code> incremental? Say
we compute the result first for some values of
<code>b</code>, <code>x</code>, <code>y</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#75715e">// computation
</span><span style="color:#75715e"></span><span style="color:#a6e22e">cond</span>(<span style="color:#66d9ef">true</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
</code></pre></div><p>It would be ideal to skip any work if the recomputation looks like <code>cond(true, 1, 3)</code>. The value of <code>y</code> is inconsequential while the first argument is <code>true</code>.
However, if <code>b</code> is <code>false</code> the situation is flipped and any change of <code>x</code>
should be inconsequential to the computation.</p>
<p>Let&rsquo;s go over the techniques we learned about in part 1. First it is clear that
naive memoization will not work. When going from <code>cond(true, 1, 1)</code>  to
<code>cond(true, 1, 3)</code> memoization will redo the whole work, while we want to do
nothing.</p>
<p>Then we can try to build the computation graph. Breaking down the computation
into basic operations we get:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">y</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">y</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">op1</span> : <span style="color:#66d9ef">op2</span>;
</code></pre></div><p><img src="/dynamic1.png" alt="Computation graph"></p>
<p>However, this still comes short as changing <code>y</code> means that even if <code>b</code> is
always <code>true</code>, the square of <code>y</code> will be computed. This is unavoidable
using the techniques we have seen so far.</p>
<p>In order to achieve better incrementality in presence of conditionals, we will
have to move to a dynamic model of computations.</p>
<h2 id="dynamic-vs-static-computation-graph">Dynamic vs Static computation graph</h2>
<p>Then depending on the last value of <code>b</code> the computation is represented by one
of the two following options.</p>
<p><img src="/dynamic-true.png" alt="cond is true graph"></p>
<p><img src="/dynamic-false.png" alt="cond is false graph"></p>
<p>The incremental algorithm should switch between the two options after reading
<code>b</code>.</p>
<p>In this example computing <code>b</code> is trivial (it is an input), but in general
there could be another sub-computation to get to it.</p>
<p>To fully support incremental computation and conditional statements one needs
to have support for a dynamically adjusting computation graph. Otherwise, the
static graph techniques will over-approximate, but still provide some value.
They will basically treat <code>op1 ? op2 : op3</code> as a basic function <code>f(op1, op2, op3)</code> that always needs all three inputs.</p>
<p>One has to be careful in using the word dynamic as here we are talking about
adjusting the computation graph, not the graph creation itself. As we have
seen in part 1, the computation graph implementations we used where build
dynamically. We still consider them static incremental computation as they
cannot adjust during re-computations.</p>
<p>Unsurprisingly, the same observations were made in the build systems space in
the paper <code>Build systems a la carte</code>. In their work they used a model for build
systems written in Haskell. Our separation between static and dynamic
computation graph is equivalent to what they call - applicative vs monadic
build systems. Most popular build systems like make are applicative (static).</p>
<h2 id="adaptive-self-adjusting-computation">Adaptive (self-adjusting) computation</h2>
<p>While turning the example above into an incremental function is relatively
easy using if-else statements (try it), a general framework that supports
dynamic incremental computation is too involved to go through in this post.</p>
<p>Luckily, this has been well studied in the past and there existing
implementations. The work of <a href="https://www.cs.cmu.edu/~rwh/theses/acar.pdf" target="_blank">Acar - Self-adjusting
computation</a> support dynamic
incremental computation in OCaml. It was slightly modified and improved by
Carlsson in <a href="https://dl.acm.org/doi/abs/10.1145/581478.581482" target="_blank">Monads for Incremental
Computing</a>.  His
implementation is in Haskell making heavy use of monads and do-notation.  I
have translated his implementation to TypeScript -
<a href="https://github.com/rkirov/adapt-comp" target="_blank">adapt-comp</a>. It required loosing some of
the heavy monadic type guarantees from the Haskell implementation, but
it caries the same basic algorithms and datatypes.</p>
<p>At this point I use the names &lsquo;self-adjusting&rsquo;, &lsquo;adaptive&rsquo; and &lsquo;incremental&rsquo;
computation interchangeably when talking about the concepts. The library
implementing the particular algorithms for incremental computation is called
&lsquo;adapt-comp&rsquo; in reference to the original work by Acar, et.al.</p>
<p>The distance function example from part 1 looks like this in adaptive
computation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#ae81ff">1</span>));
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#ae81ff">1</span>));

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>)));
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>)));
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">op1</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> 
                 <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">op2</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">=&gt;</span>
                   <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>))));
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">op3</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">x</span>)))); 

<span style="color:#75715e">// computation
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">op4</span>.<span style="color:#a6e22e">get</span>());

<span style="color:#75715e">// re-computation
</span><span style="color:#75715e"></span><span style="color:#a6e22e">write</span>(<span style="color:#a6e22e">y</span>, <span style="color:#ae81ff">3</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">op4</span>.<span style="color:#a6e22e">get</span>());
</code></pre></div><p>The basic block of <code>adapt-comp</code> are the <code>comp</code> constructor which builds a
single build block of the computation. The only argument to <code>comp</code> describes
how is the operation built. It either a basic value, which has to be wrapped
like this - <code>pure(&lt;some value&gt;)</code>, or a result of reading another variable using
the <code>read</code> function. Once a variable is read with <code>read</code>, we pass a callback
that describes what to do with the value read. The only catch is that at the
end of the callback we still have to return another <code>pure</code> or <code>read</code>.</p>
<p>(Aside: if one is familiar with monads they recognize the structure here, which
comes from the Haskell linage of this code. If not don&rsquo;t worry, this exposition
is self-contained.)</p>
<p>This is a push-based direct incremental computation using the terminology from
part 1. When one calls <code>write(y, 3)</code>, all the computations that had <code>read(y, ...)</code> have their corresponding callback retriggered, then recursively their
dependents are retriggered. At any point the last and new values are compared
and if the value hasn&rsquo;t changed the retriggering is stopped.</p>
<p>So far, this doesn&rsquo;t seems to carry its weight as we had simpler
implementations doing this in part 1. However, &lsquo;adapt-comp&rsquo; supports a dynamic
incremental computation too. Our original dynamic example looks like this in
&lsquo;adapt-comp&rsquo;:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">bVar</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#66d9ef">true</span>));
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">xVar</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#ae81ff">1</span>));
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">yVar</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#ae81ff">1</span>));

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">cond</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">bVar</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">?</span> 
                                  <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">xVar</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>)) <span style="color:#f92672">:</span>
                                  <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">yVar</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">y</span>))));
</code></pre></div><p>One convenience is that we no longer had to extract <code>op1</code> and <code>op2</code> into
separate definitions. There are implicitly objects behind the two <code>read</code> calls
that play similar role.</p>
<p>But the real benefit is that the dynamic reads during computing <code>cond</code> are
recorded on each computation and recomputation. Since <code>y</code> is not a static
dependency of <code>cond</code>, but rather something that was read (or not) as we
went along. Thus a recomputation is not triggered when y changes.</p>
<pre><code>write(y, 3);  // does not even recompute y * y
console.log(op4.get());  // immediate return of the previous value
</code></pre><h2 id="observable-example">Observable example</h2>
<p>As seen in part 1, the observable pattern and in particular RxJS implementation
allows for easy implementation of push-based incremental computation (and
more).</p>
<p>To strengthen this point this is how our example will look like in RxJS.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">of</span>, <span style="color:#a6e22e">switchMap</span>, <span style="color:#a6e22e">Subject</span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;rxjs&#39;</span>;
<span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">map</span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;rxjs/operators&#39;</span>;

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Subject</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">boolean</span><span style="color:#f92672">&gt;</span>();
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Subject</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">number</span><span style="color:#f92672">&gt;</span>();
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Subject</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">number</span><span style="color:#f92672">&gt;</span>();

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">square</span>));
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">square</span>));
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">switchMap</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">op1</span> : <span style="color:#66d9ef">op2</span>));

<span style="color:#a6e22e">op3</span>.<span style="color:#a6e22e">subscribe</span>(<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>);

<span style="color:#75715e">// initial computation
</span><span style="color:#75715e"></span><span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">next</span>(<span style="color:#66d9ef">true</span>);
<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">1</span>);
<span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">1</span>);

<span style="color:#75715e">// re-computation of with new y
</span><span style="color:#75715e"></span><span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">3</span>);  <span style="color:#75715e">// no log occurs
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// re-computation of with new x
</span><span style="color:#75715e"></span><span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">3</span>);  <span style="color:#75715e">// log 9 occurs
</span></code></pre></div><p>(Aside for readers familiar with monads: you might remember that build systems
article called systems supporting dynamic computation graphs &ndash; monadic. It is
not a coincidence that we had to use the switchMap operator here, which indeed
has the monadic interface).</p>
<p>If feels natural to do for and while loops next, but actually more primitive
concept is recursion.</p>
<h2 id="recursion">Recursion</h2>
<p>We have been focusing on a single function so far. Extending the framework to
multiple distinct functions is straight forward. Graphically, a function call
was treated as a single node, but if it is an incremental computation we can
embedded its own graph into the node to form one bigger computation graph.</p>
<p>The question of multiple calls into the same function, especially recursively
might give us a pause. Say we want to make the following recursive function
incremental:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">y</span>; 
  }
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>);
}
</code></pre></div><p>The intermediate step is to write it in the form of simple operations and conditionals:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">nextX</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">nextY</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>;
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">lessZ</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">lessZ</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">y</span> : <span style="color:#66d9ef">f</span>(<span style="color:#a6e22e">nextX</span>, <span style="color:#a6e22e">nextY</span>);
}

<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">0</span>);  <span style="color:#75715e">// returns 55;
</span></code></pre></div><p>Now we can use the <code>adapt-comp</code> library to directly translate:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#75715e">// description
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">Modifiable</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">number</span><span style="color:#f92672">&gt;</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">Modifiable</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">number</span><span style="color:#f92672">&gt;</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">Mod</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">number</span><span style="color:#f92672">&gt;</span> {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">nextX</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)));
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">nextY</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>))));
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">lessZ</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)));
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">lessZ</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">y</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">nextX</span>, <span style="color:#a6e22e">nextY</span>)))); 
}
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#ae81ff">1</span>));
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#ae81ff">1</span>));

<span style="color:#75715e">// computation
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>);
<span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">get</span>();  <span style="color:#75715e">// returns 55;
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// re-computation
</span><span style="color:#75715e"></span><span style="color:#a6e22e">write</span>(<span style="color:#a6e22e">y</span>, <span style="color:#ae81ff">100</span>);
<span style="color:#a6e22e">res</span>.<span style="color:#a6e22e">get</span>();  <span style="color:#75715e">// returns 155;
</span></code></pre></div><p>As we see there is nothing special about recursion, because we can dynamically
create new computation variables (they have the <code>Modifable&lt;T&gt;</code> interface). The
function boundaries are almost irrelevant at for the re-computation. The only
thing that matters is which computations are created <code>cond</code> and what reads have
happened during the computation.</p>
<h2 id="looping-and-mutable-variables">Looping and Mutable variables</h2>
<p>Finally, we can get to <code>for</code> and <code>while</code> loops. Unfortunately, we cannot
directly support <code>for</code> and <code>while</code> loops in the <code>adapt-comp</code> world. Calling
<code>comp</code> in a loop by itself is fine, but we cannot interleave the termination
control flow from the <code>read</code> callbacks back to original loop.</p>
<p>However, we are in luck as all <code>for</code> and <code>while</code> loops can be rewritten through
recursion. In fact the recursion example above could have been written as the
following imperative program:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">acc</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span>;
  <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
    <span style="color:#a6e22e">acc</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">x</span>; 
  }
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">acc</span>;
}
</code></pre></div><p>So we already have an incremental solution for it above.</p>
<h2 id="adding-mutable-objects-and-differential-programming">Adding mutable objects and differential programming</h2>
<p>TODO - present &ldquo;delta calculus&rdquo;.</p>
<h2 id="online-combinatorial-algorithms">Online combinatorial algorithms</h2>
<p>TODO - go over some of Tarjans&rsquo; papers.</p>
<h2 id="ui-programming">UI programming</h2>
<p>TODO - incremental programming in JS frameworks.</p>
<h2 id="other-implemenations">Other implemenations</h2>
<p>TODO - rust salsa and timely dataflow.</p>
<h2 id="conclusion">Conclusion</h2>
<p>TODO</p>
<h2 id="references">References</h2>
<ol>
<li>Mokhov, Mitchell, Jones, Build Systems à la Carte, Proc. ACM Program, 2018.</li>
<li>Magnus Carlsson. Monads for Incremental Computing. ICFP &lsquo;02 Proceedings of the seventh ACM SIGPLAN international conference on Functional programming</li>
<li>U. Acar, G. Blelloch, and R. Harper. Adaptive functional programming. In Principles of Programming Languages (POPL02), Portland, Oregon, January 2002. ACM</li>
<li>Conal Elliot, Functional Reactive Animation</li>
<li><a href="https://crates.io/crates/salsa">https://crates.io/crates/salsa</a></li>
<li><a href="https://github.com/TimelyDataflow/differential-dataflow">https://github.com/TimelyDataflow/differential-dataflow</a></li>
<li><a href="https://www.cs.princeton.edu/~appel/papers/ssafun.pdf">https://www.cs.princeton.edu/~appel/papers/ssafun.pdf</a></li>
<li><a href="https://www.jantar.org/papers/chakravarty03perspective.pdf">https://www.jantar.org/papers/chakravarty03perspective.pdf</a></li>
<li><a href="https://blog.janestreet.com/introducing-incremental/">https://blog.janestreet.com/introducing-incremental/</a></li>
</ol>

    </div>
</article>

<div class="markdown-body" id="license">
    <blockquote>
        <p>Unless otherwise noted, the content of this site is licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (CC BY-NC-SA 4.0)</a>.</p>
    </blockquote>
</div>




            </div>
            
            <div class="col-md-3 col-12 float-left" id="sidebar">
                
<div id="widget-toc">
    <h5>TOC</h5>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#incremental-computation-part-2">Incremental computation (part 2)</a></li>
    <li><a href="#conditional-statements">Conditional statements</a></li>
    <li><a href="#dynamic-vs-static-computation-graph">Dynamic vs Static computation graph</a></li>
    <li><a href="#adaptive-self-adjusting-computation">Adaptive (self-adjusting) computation</a></li>
    <li><a href="#observable-example">Observable example</a></li>
    <li><a href="#recursion">Recursion</a></li>
    <li><a href="#looping-and-mutable-variables">Looping and Mutable variables</a></li>
    <li><a href="#adding-mutable-objects-and-differential-programming">Adding mutable objects and differential programming</a></li>
    <li><a href="#online-combinatorial-algorithms">Online combinatorial algorithms</a></li>
    <li><a href="#ui-programming">UI programming</a></li>
    <li><a href="#other-implemenations">Other implemenations</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
</div>

<div id="widget-pages">
    <h5>Pages</h5>
    <ul>
        
        
        <li>
            <a href="/">Home</a>
        </li>
        
        <li>
            <a href="/about/">About</a>
        </li>
        
    </ul>
</div>
<div id="widget-tags">
    <h5>Tags</h5>
    <div>
        
        <span>
            <a href="https://rkirov.github.io/tags/incremental-computation/">incremental computation</a>
        </span>
        
    </div>
</div>
<div id="widget-links">
    <h5>Links</h5>
    <ul>
        
        <li>
            <a href="https://github.com/rkirov" target="_blank"><span>GitHub</span></a>
        </li>
        
        <li>
            <a href="https://twitter.com/radokirov" target="_blank"><span>Twitter</span></a>
        </li>
        
    </ul>
</div>

            </div>
            
            
        </div>
    </main>

    <footer>
    <div class="container-lg text-center">
        <p>&copy; 2020 <a href="https://rkirov.github.io/"></a> | Powered by <a href="https://github.com/amzrk2/hugo-theme-fuji/" target="_blank">Fuji</a> & <a href="https://gohugo.io/" target="_blank">Hugo</a> </p>
    </div>
</footer>
    




<script>
    $("#widget-toc a").click(function () {
        $("html, body").animate({
            scrollTop: $($(this).attr("href")).offset().top
        });
        return false;
    });
</script>



</body>

</html>