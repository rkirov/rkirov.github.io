<!DOCTYPE html>
<html lang="en">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.140.1">


<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/dsrkafuu/dsr-cdn-main@1/images/favicons/dsrca.ico" />



<title>Incremental Computation (part 2) - Subtly Different Semantics</title>




<meta name="keywords" content="incremental computation" />


<meta property="og:title" content="Incremental Computation (part 2)" />
<meta name="twitter:title" content="Incremental Computation (part 2)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rkirov.github.io/posts/incremental_computation_2/" /><meta property="og:description" content="We have been talking about general computation, but so far our language was
very limited. We only used function calls, numbers, and simple variable
binding.
We will slowly add more language primitives and see how to still have
full incrementality of the computation.
Conditional statements
Let&rsquo;s add a single conditional statement first.
function cond(b: boolean, x: number, y: number) {
  return b ? x * x : y * y; 
}
What does it mean to make cond incremental? Say
we compute the result first for some values of
b, x, y." />
<meta name="twitter:description" content="We have been talking about general computation, but so far our language was
very limited. We only used function calls, numbers, and simple variable
binding.
We will slowly add more language primitives and see how to still have
full incrementality of the computation.
Conditional statements
Let&rsquo;s add a single conditional statement first.
function cond(b: boolean, x: number, y: number) {
  return b ? x * x : y * y; 
}
What does it mean to make cond incremental? Say
we compute the result first for some values of
b, x, y." /><meta name="twitter:card" content="summary" /><meta property="article:published_time" content="2020-05-10T00:00:00+00:00" /><meta property="article:modified_time" content="2020-05-10T00:00:00+00:00" />


<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>




<link rel="stylesheet" href="https://rkirov.github.io/assets/css/fuji.min.b4a21b5d3eb1d0a51297e31230a65fc25e387843e45ec3a2d9176cd8d163c216d99b9b13a618b28f537c3b559ec8a408183b0fbfad48daddb9befa7d3ef90eed.css" integrity="sha512-tKIbXT6x0KUSl&#43;MSMKZfwl44eEPkXsOi2Rds2NFjwhbZm5sTphiyj1N8O1WeyKQIGDsPv61I2t25vvp9PvkO7Q==" />








</head>

<body
  data-theme="auto"
  data-theme-auto='false'
  >
    <script data-cfasync="false">
  
  var fujiThemeData = localStorage.getItem('fuji_data-theme');
  
  if (!fujiThemeData) {
    localStorage.setItem('fuji_data-theme', 'auto');
  } else {
    
    if (fujiThemeData !== 'auto') {
      document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
    }
  }
</script>

    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://rkirov.github.io/">Subtly Different Semantics</a>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://rkirov.github.io/posts/incremental_computation_2/">Incremental Computation (part 2)</a>
    </h2>
    <div class="post-item post-meta">
        <span><i class="iconfont icon-today-sharp"></i>&nbsp;2020-05-10</span>



<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href="/tags/incremental-computation">incremental computation</a>&nbsp;</span>

    </div>
    
    <div class="post-content markdown-body">
        <p>We have been talking about general computation, but so far our language was
very limited. We only used function calls, numbers, and simple variable
binding.</p>
<p>We will slowly add more language primitives and see how to still have
full incrementality of the computation.</p>
<h2 id="conditional-statements">Conditional statements</h2>
<p>Let&rsquo;s add a single conditional statement first.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">cond</span>(<span style="color:#a6e22e">b</span>: <span style="color:#66d9ef">boolean</span>, <span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span> : <span style="color:#66d9ef">y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">y</span>; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What does it mean to make <code>cond</code> incremental? Say
we compute the result first for some values of
<code>b</code>, <code>x</code>, <code>y</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#75715e">// computation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">cond</span>(<span style="color:#66d9ef">true</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
</span></span></code></pre></div><p>It would be ideal to skip any work if the recomputation looks like <code>cond(true, 1, 3)</code>. The value of <code>y</code> is inconsequential while the first argument is <code>true</code>.
However, if <code>b</code> is <code>false</code> the situation is flipped and any change of <code>x</code>
should be inconsequential to the computation.</p>
<p>Let&rsquo;s go over the techniques we learned about in part 1. First it is clear that
naive memoization will not work. When going from <code>cond(true, 1, 1)</code>  to
<code>cond(true, 1, 3)</code> memoization will redo the whole work, while we want to do
nothing.</p>
<p>Then we can try to build the computation graph. Breaking down the computation
into basic operations we get:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">y</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">y</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">op1</span> : <span style="color:#66d9ef">op2</span>;
</span></span></code></pre></div><p><img class="img-zoomable" src="/dynamic1.png" alt="Computation graph" />
</p>
<p>However, this still comes short as changing <code>y</code> means that even if <code>b</code> is
always <code>true</code>, the square of <code>y</code> will be computed. This is unavoidable
using the techniques we have seen so far.</p>
<p>In order to achieve better incrementality in presence of conditionals, we will
have to move to a dynamic model of computations.</p>
<h2 id="dynamic-vs-static-computation-graph">Dynamic vs Static computation graph</h2>
<p>The right viewpoint is that depending on the last value of <code>b</code> the computation
is represented by one of the two following options.</p>
<p><img class="img-zoomable" src="/dynamic-true.png" alt="cond is true graph" />
</p>
<p><img class="img-zoomable" src="/dynamic-false.png" alt="cond is false graph" />
</p>
<p>The incremental algorithm should switch between the two options after reading
<code>b</code>.</p>
<p>In this example computing <code>b</code> is trivial (it is an input), but in general
there could be another sub-computation to get to it.</p>
<p>To fully support incremental computation and conditional statements one needs
to have support for a dynamically adjusting computation graph. Otherwise, the
static graph techniques can still be used, but they will be an
over-approximation.  They will basically treat <code>op1 ? op2 : op3</code> as a function
<code>f(op1, op2, op3)</code> that always needs all three inputs.</p>
<p>One has to be careful in using the word dynamic as here we are talking about
adjusting the computation graph, not the graph creation itself. As we have
seen in part 1, the computation graph implementations we used where build
dynamically. We still consider them static incremental computation as they
cannot adjust during re-computations.</p>
<p>Unsurprisingly, the same observations were made in the build systems space in
the paper <code>Build systems a la carte</code> (see refs in part 3). In their work they
used a model for build systems written in Haskell. Our separation between
static and dynamic computation graph is equivalent to what they call -
applicative vs monadic build systems. Most popular build systems like <code>make</code>
are applicative (static).</p>
<h2 id="adaptive-self-adjusting-computation">Adaptive (self-adjusting) computation</h2>
<p>While turning the example above into an incremental function is relatively easy
using <code>if-else</code> statements (try it), a general framework that supports dynamic
incremental computation is too involved to go through in this post.</p>
<p>Luckily, this has been well studied in the past and there existing
implementations. The work of <a href="https://www.cs.cmu.edu/~rwh/theses/acar.pdf" target="_blank">Acar - Self-adjusting
computation</a> support dynamic
incremental computation in OCaml. It was slightly modified and improved by
Carlsson in <a href="https://dl.acm.org/doi/abs/10.1145/581478.581482" target="_blank">Monads for Incremental
Computing</a>.  His
implementation is in Haskell making heavy use of monads and do-notation.  I
have translated his implementation to TypeScript -
<a href="https://github.com/rkirov/adapt-comp" target="_blank">adapt-comp</a>. It required losing some of
the heavy monadic type guarantees from the Haskell implementation, but
it caries the same basic algorithms and datatypes.</p>
<p>At this point I use the names &lsquo;self-adjusting&rsquo;, &lsquo;adaptive&rsquo; and &lsquo;incremental&rsquo;
computation interchangeably when talking about the concepts. The library
implementing the particular algorithms for incremental computation is called
&lsquo;adapt-comp&rsquo; in reference to the original work by Acar, et.al.</p>
<p>The distance function example from part 1 of the blog post looks like this
using the library:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>)));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>)));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">op1</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> 
</span></span><span style="display:flex;"><span>                 <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">op2</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">=&gt;</span>
</span></span><span style="display:flex;"><span>                   <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>))));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">op3</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">x</span>)))); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// computation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">op4</span>.<span style="color:#66d9ef">get</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// re-computation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">write</span>(<span style="color:#a6e22e">y</span>, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">op4</span>.<span style="color:#66d9ef">get</span>());
</span></span></code></pre></div><p>The basic block of <code>adapt-comp</code> are the <code>comp</code> constructor which builds a
single build block of the computation. The only argument to <code>comp</code> describes
how is the operation built. It either a basic value, which has to be wrapped
like this - <code>pure(&lt;some value&gt;)</code>, or a result of reading another variable using
the <code>read</code> function. Once a variable is read with <code>read</code>, we pass a callback
that describes what to do with the value that was just read. The only catch is
that at the end of the callback we still have to return another <code>pure</code> or
<code>read</code>.</p>
<p>(Aside: if one is familiar with monads they recognize the structure here, which
comes from the Haskell linage of this code. If not don&rsquo;t worry, my exposition
is self-contained.)</p>
<p>This is a push-based direct incremental computation using the terminology from
part 1, as we observed that it leads to the easiest way to add incrementality.
When one calls <code>write(y, 3)</code>, all the computations that had <code>read(y, ...)</code> have
their corresponding callback retriggered, then recursively their dependents are
retriggered, and so on. At any point the last and new values are compared and
if the value hasn&rsquo;t changed the retriggering is stopped.</p>
<p>So far, this doesn&rsquo;t seems to carry its weight as we had simpler
implementations doing this in part 1. However, &lsquo;adapt-comp&rsquo; supports a dynamic
incremental computation too. Our original dynamic example looks like this in
&lsquo;adapt-comp&rsquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">bVar</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#66d9ef">true</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">xVar</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">yVar</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">cond</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">bVar</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">?</span> 
</span></span><span style="display:flex;"><span>                                  <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">xVar</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>)) <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                                  <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">yVar</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">y</span>))));
</span></span></code></pre></div><p>One convenience is that we no longer had to extract <code>op1</code> and <code>op2</code> into
separate definitions. There are implicitly objects behind the two <code>read</code> calls
that play similar role.</p>
<p>But the real benefit is that the dynamic reads during computing <code>cond</code> are
recorded on each computation and recomputation. Since <code>y</code> is not a static
dependency of <code>cond</code>, but rather something that was read (or not) as we
went along. Thus a recomputation is not triggered when y changes.</p>
<pre tabindex="0"><code>write(y, 3);  // does not even recompute y * y
console.log(op4.get());  // immediate return of the previous value
</code></pre><h2 id="observable-example">Observable example</h2>
<p>As seen in part 1, the observable pattern and in particular RxJS implementation
allows for easy implementation of push-based incremental computation (and
much more).</p>
<p>To strengthen this point this is how our example will look like in RxJS.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> {<span style="color:#66d9ef">of</span>, <span style="color:#a6e22e">switchMap</span>, <span style="color:#a6e22e">Subject</span>} <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;rxjs&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">map</span>, <span style="color:#a6e22e">distinctUntilChanged</span>} <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;rxjs/operators&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Subject</span>&lt;<span style="color:#f92672">boolean</span>&gt;();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Subject</span>&lt;<span style="color:#f92672">number</span>&gt;();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Subject</span>&lt;<span style="color:#f92672">number</span>&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">square</span>), <span style="color:#a6e22e">distinctUntilChanged</span>());
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">square</span>), <span style="color:#a6e22e">distinctUntilChanged</span>());
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">switchMap</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">op1</span> : <span style="color:#66d9ef">op2</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">op3</span>.<span style="color:#a6e22e">subscribe</span>(<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// initial computation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">next</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// re-computation of with new y
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">3</span>);  <span style="color:#75715e">// no log occurs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// re-computation of with new x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">3</span>);  <span style="color:#75715e">// log 9 occurs
</span></span></span></code></pre></div><p>(Aside for readers familiar with monads: you might remember that build systems
article called systems supporting dynamic computation graphs &ndash; monadic. It is
not a coincidence that we had to use the switchMap operator here, which indeed
has the monadic interface).</p>
<p>If feels natural to do for and while loops next, but actually more primitive
concept is recursion.</p>
<h2 id="recursion">Recursion</h2>
<p>We have been focusing on a single function so far. Extending the framework to
multiple distinct functions is straight forward. Graphically, a function call
was treated as a single node, but if it is an incremental computation we can
embedded its own graph into another node to form one bigger computation graph.</p>
<p>The question of multiple calls into the same function, especially recursively
might give us a pause. Say we want to make the following recursive function
incremental:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">y</span>; 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The intermediate step is to write it in the form of simple operations and conditionals:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">nextX</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">nextY</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">lessZ</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">lessZ</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">y</span> : <span style="color:#66d9ef">f</span>(<span style="color:#a6e22e">nextX</span>, <span style="color:#a6e22e">nextY</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">0</span>);  <span style="color:#75715e">// returns 55;
</span></span></span></code></pre></div><p>Now we can use the <code>adapt-comp</code> library to directly translate:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#75715e">// description
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">Modifiable</span>&lt;<span style="color:#f92672">number</span>&gt;, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">Modifiable</span>&lt;<span style="color:#f92672">number</span>&gt;)<span style="color:#f92672">:</span> <span style="color:#a6e22e">Mod</span>&lt;<span style="color:#f92672">number</span>&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">nextX</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)));
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">nextY</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>))));
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">lessZ</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">x</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)));
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">lessZ</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">y</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">nextX</span>, <span style="color:#a6e22e">nextY</span>)))); 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#ae81ff">10</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// computation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">res</span>.<span style="color:#66d9ef">get</span>();  <span style="color:#75715e">// returns 55;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// re-computation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">write</span>(<span style="color:#a6e22e">y</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">res</span>.<span style="color:#66d9ef">get</span>();  <span style="color:#75715e">// returns 155;
</span></span></span></code></pre></div><p>As we see there is nothing special about recursion, because we can dynamically
create new computation variables. The function boundaries are almost irrelevant
for the re-computation. The only thing that matters is which computations are
created by <code>comp</code> and what reads have happened during the computation.</p>
<h2 id="looping-and-mutable-variables">Looping and Mutable variables</h2>
<p>Finally, we can get to <code>for</code> and <code>while</code> loops. Unfortunately, we cannot
directly support <code>for</code> and <code>while</code> loops in the <code>adapt-comp</code> world. Calling
<code>comp</code> in a loop by itself is fine, but we cannot interleave the termination
control flow from the <code>read</code> callbacks back to original loop.</p>
<p>However, we are in luck as all <code>for</code> and <code>while</code> loops can be rewritten through
recursion. In fact the recursion example above could be seen as the functional
rewrite for the following imperative program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sumUp</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">acc</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">acc</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">x</span>; 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">acc</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So we already have an incremental solution for it above.</p>
<p>This example, also shows one of the failures of incremental computation, by
virtue of it being so general, it does not take into account the algebraic
properties of <code>+</code> (commutativity, associtivity, etc.)</p>
<p>If we recompute <code>sumUp(10, 100)</code> after <code>sumUp(10, 0)</code> it is clear to us that
the best way to do it is through simply adding <code>100</code> to the old result. But
the incremental program we have above sees the computation as:</p>
<pre tabindex="0"><code>(100 + ... + (3 + (2 + (1 + (0 + 0))))) 
</code></pre><p>where the last <code>0</code> is <code>y</code>. Changing it to <code>100</code> busts the whole chain of computation
and all additions get redone. We know that doesn&rsquo;t seem efficient, the
incremental computation show just add <code>100</code> to the previous result.</p>
<p>Now that is not unavoidable as one can write the computation using the
algebraic properties of <code>+</code>:</p>
<pre tabindex="0"><code>(100 + ... + (3 + (2 + (1 + 0)))) + 0
</code></pre><p>But an automated framework cannot do that without some knowledge about the
properies of <code>+</code>. The user herself can write the computation in that form from
the beginning, but that goes against the promise that the incremental program
is easily extracted by code transformation from from the original computation.</p>
<p>Moreover, once the user has to think about incrementality they can write by
hand this <code>update</code> function for <code>sumUp</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">updateSumUpForNewY</span>(<span style="color:#a6e22e">oldSum</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">deltaY</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">oldSum</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">deltaY</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">sum</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">sumUp</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">updateSum</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">updateSumUpForNewY</span>(<span style="color:#a6e22e">sum</span>, <span style="color:#ae81ff">100</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>This leads to a completely new way of viewing incremental computation, inspired
by the mathematics of differences. Instead of merely tracking <strong>which</strong> input
and computation has changed and which has not, we can extend the model to add
information on <strong>how</strong> has the input changed.</p>
<h2 id="the-computational-derivative">The Computational Derivative</h2>
<p>To move to an even more mathematical notation, if the original function is <code>f(x, y)</code> and we want to compute <code>f(x', y')</code>, an incremental way of computing it
would be to use <code>f(x, y) ⊕ f'(x, y, Δx, Δy))</code> where <code>Δx = x' ⊖ x</code> and <code>Δy = y' ⊖ x</code>. The reads roughly as &rsquo;to compute the new output, we add the old output to
the result of some special function <code>f'</code> that consumes the old inputs and their
changes&rsquo;.</p>
<p>Why the circles around <code>+</code> and <code>-</code>? Because we didn&rsquo;t specify the
types these are generic ways of creating <code>⊕</code>, and applying <code>⊖</code> diffs for some
given type. For <code>number</code> as the input type, these are literally <code>+</code> and <code>-</code> and
the diff type is <code>number</code>.  However, for <code>number[]</code> the diff structure will
have to be more complicated.  One-way to model it is using diffs as
<code>{additions: {idx: number, newVal: number}[], deletions: number[]}</code>, where <code>⊕</code>
and <code>⊖</code> apply or extract these diffs onto number arrays.</p>
<p>What about <code>f'</code>?  That&rsquo;s the <em>computational derivative</em>. If we can have that
function in a form that it is cheaper to compute than the original <code>f</code>, we have
succeeded at the goals of creating an incremental computation.</p>
<p>In our example above <code>sumUpTo'</code> is</p>
<pre tabindex="0"><code>function sumUpTo&#39;(newX: number, newY: number, deltaX: number, deltaY: number) {
  return (2 * newX - deltaX + 1) / 2 - deltaY;  
}
</code></pre><p>Of course, I cheated in creating this by applying well-known mathematical
equalities (check my work). The question of interest is how to extract that
from the original function definition. Can this be done for any general
computation, not just numerical?</p>
<p>Deriving such derivative function in the lambda calculus is described in the
paper <a href="https://arxiv.org/abs/1312.0658" target="_blank">A Theory of Changes for Higher-Order
Languages</a>. It includes a prototype Scala
implementation, which I have not had a chance to explore further. On the
practical side the OCaml Incremental library has added support for diffable
data <a href="https://blog.janestreet.com/self-adjusting-dom-and-diffable-data/" target="_blank">Self Adjusting DOM and Diffable
Data</a>,
specifically for mutable data structures that we will explore in a bit.</p>
<p>It is unclear to me whether the diffable addition to incremental computation is
objectively different approach compared to the basic methods we have discussed
for far or an optimization to support the pragmatics of mutable data
structures. Let me know what do you think.</p>
<h2 id="automatic-differentiation-aside">Automatic-differentiation aside</h2>
<p>If you have been following you the machine learning community this might
light-bulb - automatic differentiation!</p>
<p>Unfortunately, the computational derivative for a function that deals with
numerics is not the same as the mathematical derivative for the underlying math
function. Mathematically, the computational derivative is just the difference
function <code>f(x') - f(x)</code>.  Different forms of writing that function (with some
being faster to compute) is question in the domain of computer science and not
mathematics.</p>
<p>That said the study of applying program transformations to extract the
mathematical derivative has a lot of parallels with the techniques for
incremental computation. The paper <a href="https://arxiv.org/abs/1803.10228" target="_blank">Demystifying Differentiable Programming:
Shift/Reset the Penultimate Backpropagator </a>
is a great overview on the subject.</p>
<h2 id="data-structures">Data structures</h2>
<p>You might have noticed that all the functions so far only dealt with numbers.
That was intentional, as adding lists and maps to incremental computation, will
present another divergent point.</p>
<p>One way we can approach this problem is sticking to the purely functional
paradigm. We can build lists out of pairs of value and a next pointer, and
trees as value with two pointers.  Using the <code>adapt-comp</code> library again and its
core <code>Modifiable&lt;T&gt;</code> type, these structures can be written as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IncrementalList</span>&lt;<span style="color:#f92672">T</span>&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">next</span>: <span style="color:#66d9ef">Modifiable</span>&lt;<span style="color:#f92672">IncrementalList</span><span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">T</span>&gt;<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IncrementalTree</span>&lt;<span style="color:#f92672">T</span>&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">left</span>: <span style="color:#66d9ef">Modifiable</span>&lt;<span style="color:#f92672">IncrementalTree</span><span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">T</span>&gt;<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">rigth</span>: <span style="color:#66d9ef">Modifiable</span>&lt;<span style="color:#f92672">IncrementalTree</span><span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#a6e22e">T</span>&gt;<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally, a <code>Map&lt;K,V&gt;</code> API can be added as implemented by lists of entries or a
balanced tree using standard functional constructions.</p>
<p>Once we have data structures, we can add algorithms. For example, this is how
incremental quick sort looks like -
<a href="https://github.com/rkirov/adapt-comp/blob/master/examples/aqsort.ts" target="_blank">aqsort.ts</a>.
The incremental version of the quick sort takes on average <code>O(log n)</code> to update
for a single new insertion.</p>
<p>As this example show, embedding incremental computation into a non-computation
language like JS is possible, but unnatural. We have to rebuild a
mini-functional language by avoiding the built-in control flow and data
structures.</p>
<p>The alternative is to provide a bridge with the mutable world where data
structures are not built out of incremental bindings. That brings us back
to the differential model where data structures come with their own
definitions of deltas (also called diffs), computing deltas, applying
deltas, and propagating them incrementally though all methods.</p>
<p>For example, Jane street&rsquo;s incremental has diffing extensions for
<a href="https://github.com/janestreet/incr_map" target="_blank">maps</a> and <a href="https://github.com/janestreet/incremental/blob/d70ce14c30694c2b735c0dd76734756302dcdd8f/src/unordered_array_fold.ml" target="_blank">unordered
arrays</a>, to support Ocaml&rsquo;s native maps and list in a more fine grained
way than treating them as opaque objects that either change or not.</p>
<h2 id="incremental-records">Incremental records</h2>
<p>Records represent one of the easiest data structures to incrementalize.
Because they are not statically changing structure like lists and maps.</p>
<p>Consider the following example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Person</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">addres</span>: <span style="color:#66d9ef">string</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Incremental</span>&lt;<span style="color:#f92672">T</span>&gt; <span style="color:#f92672">=</span> {[<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">keysof</span> <span style="color:#a6e22e">T</span>]<span style="color:#f92672">:</span> <span style="color:#a6e22e">Modifiable</span>&lt;<span style="color:#f92672">T</span><span style="color:#960050;background-color:#1e0010">[</span><span style="color:#a6e22e">key</span><span style="color:#960050;background-color:#1e0010">]</span>&gt;};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span>: <span style="color:#66d9ef">Incremental</span>&lt;<span style="color:#f92672">Person</span>&gt; <span style="color:#f92672">=</span> {<span style="color:#a6e22e">name</span>: <span style="color:#66d9ef">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#e6db74">&#39;John Smith&#39;</span>)), <span style="color:#a6e22e">address</span>: <span style="color:#66d9ef">comp</span>(<span style="color:#a6e22e">pure</span>(<span style="color:#e6db74">&#39;neverland&#39;</span>))};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">businessCard</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">comp</span>(<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">n</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">addr</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">pure</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">p</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> at </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">addr</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>))));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// computation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">businessCard</span>.<span style="color:#66d9ef">get</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// recomputation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">write</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">name</span>, <span style="color:#e6db74">&#39;Jane Smith&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">businessCard</span>.<span style="color:#66d9ef">get</span>();
</span></span></code></pre></div><p>The <a href="https://github.com/salsa-rs" target="_blank">salsa framework in Rust</a> relies on this
observation to only support static object definitions. Through macros a lot of
the supporting machinery is generated on predefined functions instead of being
as dynamic as the incremental implementations above. An extra layer of
extensibility is added through supporting keys per object - think <code>p['John Doe'].name</code>. As long as there are no methods working over the collection as a
whole (no map, reduce, etc) this is a simpler model than general incremental
computation, but still expressive enough to help with writing incremental
compilers.</p>
<h2 id="online-combinatorial-algorithms">Online combinatorial algorithms</h2>
<p>You might wonder what is the downside to adding the differential view since it
lets us use more complicated data structures and methods on them. The problem
is that at the low level we only have a handful a primitives, once we start
climbing up the abstraction stack there is a whole zoo of data structures
and methods that have to be supported.</p>
<p>At the extreme there are fully custom data structures that support very
efficient results to a fixed set of computations, after small changes. This
work of Tarjan is representative - [A Data Structure for Dynamic Trees]
(<a href="https://www.cs.cmu.edu/~sleator/papers/dynamic-trees.pdf%29" target="_blank">https://www.cs.cmu.edu/~sleator/papers/dynamic-trees.pdf)</a>. One of the
original goals of research of incremental computation was to automatically
derive these type of structures through incrementalizing the classical
algorithms, instead of incremenlizing them one by one.</p>
<h2 id="onto-part-2">Onto part 2</h2>
<p>This concludes the introduction into incremental computation, in part 3 we will
talk about applications to UI programming and conclude the series.</p>
<p><a href="/posts/incremental_computation_3">Continue to part 3 of the post</a></p>

    </div>
</article>




            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
            <li>
                <a href="https://github.com/rkirov" target="_blank"><span>GitHub</span></a>
            </li>
            
            <li>
                <a href="https://twitter.com/radokirov" target="_blank"><span>Twitter</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tags</h3>
        <div>
            
            <span>
                <a href="/tags/incremental-computation/">Incremental Computation</a>
            </span>
            
        </div>
    </div>
    <div class="sidebar-item sidebar-toc">
        <h3>Table of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#conditional-statements">Conditional statements</a></li>
    <li><a href="#dynamic-vs-static-computation-graph">Dynamic vs Static computation graph</a></li>
    <li><a href="#adaptive-self-adjusting-computation">Adaptive (self-adjusting) computation</a></li>
    <li><a href="#observable-example">Observable example</a></li>
    <li><a href="#recursion">Recursion</a></li>
    <li><a href="#looping-and-mutable-variables">Looping and Mutable variables</a></li>
    <li><a href="#the-computational-derivative">The Computational Derivative</a></li>
    <li><a href="#automatic-differentiation-aside">Automatic-differentiation aside</a></li>
    <li><a href="#data-structures">Data structures</a></li>
    <li><a href="#incremental-records">Incremental records</a></li>
    <li><a href="#online-combinatorial-algorithms">Online combinatorial algorithms</a></li>
    <li><a href="#onto-part-2">Onto part 2</a></li>
  </ul>
</nav></div>
</aside>

        </div>
        <div class="btn">
    <div class="btn-menu" id="btn-menu">
        <i class="iconfont icon-grid-sharp"></i>
    </div>
    <div class="btn-toggle-mode">
        <i class="iconfont icon-contrast-sharp"></i>
    </div>
    <div class="btn-scroll-top">
        <i class="iconfont icon-chevron-up-circle-sharp"></i>
    </div>
</div>
<aside class="sidebar-mobile" style="display: none;">
  <div class="sidebar-wrapper">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
            <li>
                <a href="https://github.com/rkirov" target="_blank"><span>GitHub</span></a>
            </li>
            
            <li>
                <a href="https://twitter.com/radokirov" target="_blank"><span>Twitter</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tags</h3>
        <div>
            
            <span>
                <a href="/tags/incremental-computation/">Incremental Computation</a>
            </span>
            
        </div>
    </div>
    
    
    
    
  </div>
</aside>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            
            <span>&copy; 2024
                <a href="https://rkirov.github.io/"></a>
                
                | Powered by <a href="https://github.com/dsrkafuu/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> &amp; <a href="https://gohugo.io/"
                                                    target="_blank">Hugo</a> 
            </span>
        </div>
    </div>
</footer>

    
<script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js" integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js" integrity="sha512-LCKPTo0gtJ74zCNMbWw04ltmujpzSR4oW+fgN+Y1YclhM5ZrHCZQAJE4quEodcI/G122sRhSGU2BsSRUZ2Gu3w==" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-GP4x8UWxWyh4BMbyJGOGneiTbkrWEF5izsVJByzVLodP8CuJH/n936+yQDMJJrOPUHLgyPbLiGw2rXmdvGdXHA==" crossorigin="anonymous"></script>



<script defer src="/assets/js/fuji.min.645f1123be695831f419ab54c1bcba327325895c740014006e57070d4f3e5d6b553e929c4b46f40ea707249e9c7f7c2a446d32a39ce7319f80a34525586a8e0f.js" integrity="sha512-ZF8RI75pWDH0GatUwby6MnMliVx0ABQAblcHDU8&#43;XWtVPpKcS0b0DqcHJJ6cf3wqRG0yo5znMZ&#43;Ao0UlWGqODw=="></script>



</body>

</html>
