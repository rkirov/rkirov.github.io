<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Is this JS function pure? | Rado&#39;s Radical Reflections</title>
<meta name="title" content="Is this JS function pure?" />
<meta name="description" content="Is this JS function pure?
In 2019, as functional programming was making the last
inroads dethroning OOP, I kept hearing the mantra of
&ldquo;just use pure functions&rdquo; in JS. Something didn&rsquo;t sit
right with me when talking very deterministically about
pure functions in a large unpure language like JS.
Especially, after seeing JS tooling perform
optimizations based on a pure annotation (like webpack).
While everyone agrees x =&gt; x &#43; 2 is pure, I felt there
are a lot of subtle situations where disagreements might
arise. What is worse than terms with imprecise meaning
is terms with imprecise meaning where people using them
are not aware there is imprecision." />
<meta name="keywords" content="" />


<meta property="og:url" content="https://rkirov.github.io/posts/pure/">
  <meta property="og:site_name" content="Rado&#39;s Radical Reflections">
  <meta property="og:title" content="Is this JS function pure?">
  <meta property="og:description" content="Is this JS function pure? In 2019, as functional programming was making the last inroads dethroning OOP, I kept hearing the mantra of “just use pure functions” in JS. Something didn’t sit right with me when talking very deterministically about pure functions in a large unpure language like JS. Especially, after seeing JS tooling perform optimizations based on a pure annotation (like webpack).
While everyone agrees x =&gt; x &#43; 2 is pure, I felt there are a lot of subtle situations where disagreements might arise. What is worse than terms with imprecise meaning is terms with imprecise meaning where people using them are not aware there is imprecision.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-11-11T20:18:26-08:00">
    <meta property="article:modified_time" content="2025-11-11T20:18:26-08:00">




  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Is this JS function pure?">
  <meta name="twitter:description" content="Is this JS function pure? In 2019, as functional programming was making the last inroads dethroning OOP, I kept hearing the mantra of “just use pure functions” in JS. Something didn’t sit right with me when talking very deterministically about pure functions in a large unpure language like JS. Especially, after seeing JS tooling perform optimizations based on a pure annotation (like webpack).
While everyone agrees x =&gt; x &#43; 2 is pure, I felt there are a lot of subtle situations where disagreements might arise. What is worse than terms with imprecise meaning is terms with imprecise meaning where people using them are not aware there is imprecision.">
      <meta name="twitter:site" content="@radokirov">




  <meta itemprop="name" content="Is this JS function pure?">
  <meta itemprop="description" content="Is this JS function pure? In 2019, as functional programming was making the last inroads dethroning OOP, I kept hearing the mantra of “just use pure functions” in JS. Something didn’t sit right with me when talking very deterministically about pure functions in a large unpure language like JS. Especially, after seeing JS tooling perform optimizations based on a pure annotation (like webpack).
While everyone agrees x =&gt; x &#43; 2 is pure, I felt there are a lot of subtle situations where disagreements might arise. What is worse than terms with imprecise meaning is terms with imprecise meaning where people using them are not aware there is imprecision.">
  <meta itemprop="datePublished" content="2025-11-11T20:18:26-08:00">
  <meta itemprop="dateModified" content="2025-11-11T20:18:26-08:00">
  <meta itemprop="wordCount" content="1056">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  body {
    font-family: Verdana, sans-serif;
    margin: auto;
    padding: 20px;
    max-width: 720px;
    text-align: left;
    background-color: #fff;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: #444;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  strong,
  b {
    color: #222;
  }

  a {
    color: #3273dc;
     
  }

  .title {
    text-decoration: none;
    border: 0;
  }

  .title span {
    font-weight: 400;
  }

  nav a {
    margin-right: 10px;
  }

  textarea {
    width: 100%;
    font-size: 16px;
  }

  input {
    font-size: 16px;
  }

  content {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  img {
    max-width: 100%;
  }

  code {
    padding: 2px 5px;
    background-color: #f2f2f2;
  }

  pre code {
    color: #222;
    display: block;
    padding: 20px;
    white-space: pre-wrap;
    font-size: 14px;
    overflow-x: auto;
  }

  div.highlight pre {
    background-color: initial;
    color: initial;
  }

  div.highlight code {
    background-color: unset;
    color: unset;
  }

  blockquote {
    border-left: 1px solid #999;
    color: #222;
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px;
    text-align: center;
  }

  .helptext {
    color: #777;
    font-size: small;
  }

  .errorlist {
    color: #eba613;
    font-size: small;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: #8b6fcb;
  }

  @media (prefers-color-scheme: dark) {
    body {
      background-color: #333;
      color: #ddd;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    strong,
    b {
      color: #eee;
    }

    a {
      color: #8cc2dd;
    }

    code {
      background-color: #777;
    }

    pre code {
      color: #ddd;
    }

    blockquote {
      color: #ccc;
    }

    textarea,
    input {
      background-color: #252525;
      color: #ddd;
    }

    .helptext {
      color: #aaa;
    }
  }

</style>

</head>

<body>
  <header><a href="/" class="title">
  <h2>Rado&#39;s Radical Reflections</h2>
</a>
<nav><a href="/">Home</a>

<a href="/posts/">Blog</a>

<a href="/about/">About</a>


</nav>
</header>
  <main>

<content>
  <h1 id="is-this-js-function-pure">Is this JS function pure?</h1>
<p>In 2019, as functional programming was making the last
inroads dethroning OOP, I kept hearing the mantra of
&ldquo;just use pure functions&rdquo; in JS. Something didn&rsquo;t sit
right with me when talking very deterministically about
pure functions in a large unpure language like JS.
Especially, after seeing JS tooling perform
optimizations based on a pure annotation <a href="https://webpack.js.org/guides/tree-shaking/">(like webpack)</a>.</p>
<p>While everyone agrees <code>x =&gt; x + 2</code> is pure, I felt there
are a lot of subtle situations where disagreements might
arise. What is worse than terms with imprecise meaning
is terms with imprecise meaning where people using them
are not aware there is imprecision.</p>
<p>Wikipedia defines <a href="https://en.wikipedia.org/wiki/Pure_function">pure function</a> as a function that:</p>
<ul>
<li>returns identical values for identical arguments.</li>
<li>has no side-effects (no mutation of non-local variables, mutable reference arguments or input/output streams).</li>
</ul>
<p>So I ran a <a href="https://x.com/radokirov/status/1097325661658570752">twitter poll</a> with 10 not so obviously pure (or not) functions.
This blog post is a summary of that poll and results amongst the 383 respondents (presumably most JS developers that follow me).</p>
<h2 id="question-1">Question 1</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Math.<span style="color:#a6e22e">random</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/q1.png" alt="Q1 answers"></p>
<p>My take - clearly fails the first property for pure, so impure. Whether it has a side-effect, is surprisingly
subtle, and depends on whether one sees the internal change of the pseudorandom number generator as a side-effect or not.
Appears my audience was similarly split on the side-effect question.</p>
<h2 id="question-2">Question 2</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>My take - this example forces one to confront the fact that in the definition of pure, we need to pick a
definition of equality. JavaScript only has referential equality build in, so to me it would be the only
reasonable choice, hence not pure. This was a minority view amongst the replies.</p>
<p><img src="/q2.png" alt="Q2 answers"></p>
<h2 id="question-3">Question 3</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> () =&gt; <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>My take - A variation of Q2. My answer would be the same. I was hoping the structural equality crowd to
get a bit less comfortable here - what would &ldquo;structural equality&rdquo; mean for functions. I could have pushed this
further towards extensional and intentional equality for functions - are <code>(a) =&gt; a + a</code> and <code>(a) =&gt; 2 * a</code> equal
as pure functions. What about <code>(a) =&gt; a</code> vs <code>(b) =&gt; b</code>?</p>
<p><img src="/q3.png" alt="Q3 answers"></p>
<h2 id="question-4">Question 4</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#e6db74">&#39;oops&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/q4.png" alt="Q4 answers"></p>
<p>My take - is throwing an error a side-effect or just an alternative &ldquo;return&rdquo; value? I tend to think
the former. The responses were very split here.</p>
<p>Somewhat hilariously, I just noticed that I wrote <code>return throw 'oops'</code> in the original post, which is a
syntax error in JS, and a whole different can of worms, especially if a static analyzer is trying to determine
purity on code that might contain errors.</p>
<h2 id="question-5">Question 5</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// DEBUG_FLAG is usually false.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">DEBUG_FLAG</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;debug&#39;</span>, <span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/q5.png" alt="Q5 answers"></p>
<p>My take - logging is pretty canonically accepted as a side-effect, but I threw in some wrinkle around DEBUG_FLAG,
to add extra confusion around the effect potentially not occurring. There is an extra layer of provocation on
whether &ldquo;pure&rdquo; is a statically determinable property, or a runtime attribute of a particular invocation (depending on the
state of the <code>DEBUG_FLAG</code> at the particular invocation). Finally, reading a variable like DEBUG_FLAG in JS can be seen as a side-effect (later questions also explore that).</p>
<h2 id="question-6">Question 6</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">y</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/q6.png" alt="Q6 answers"></p>
<p>My take - Is reading a non-local const variable a side-effect? I lean yes, but there were some folks that disagreed with this.</p>
<h2 id="question-7">Question 7</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// only f has access to _memoize.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">_memoize</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">_memoize</span>.<span style="color:#a6e22e">has</span>(<span style="color:#a6e22e">x</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_memoize</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_memoize</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">res</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/q7.png" alt="Q7 answers"></p>
<p>My take - despite what the comment tries to convince you, the map is a non-local object that has observable change,
so this is an impure function.</p>
<h2 id="question-8">Question 8</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// only f mentions _privateProp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">_privateProp</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/q8.png" alt="Q8 answers"></p>
<p>My take - same as Q7, the principled answer is non-local mutation is happening so impure (even if no one is observing it)</p>
<h2 id="question-9">Question 9</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">obj</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">someProp</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/q9.png" alt="Q9 answers"></p>
<p>My take - consistently using referential equality, this function can return different results for equal inputs. Reading
a property can be seen as a side-effect as JS allows for getter methods. The survey responders did not agree, and
overwhelmingly declared this function pure.</p>
<h2 id="question-10">Question 10</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">A_REGEXP</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">/abc/g</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">A_REGEXP</span>.<span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/q10.png" alt="Q10 answers"></p>
<p>My take - a bit of a gotcha, but turns out regexps in JS mutate state on the global RegExp object, so this function
has side-effects.</p>
<h1 id="takeaways">Takeaways</h1>
<p>This survey reveals that &ldquo;pure function&rdquo; means different things to different JavaScript developers. Among the 383 respondents, there was significant disagreement on nearly every question, showing that the term is far fuzzier than most realize.</p>
<p>The core issue is that &ldquo;pure function&rdquo; is a theoretical computer science concept being applied to a practical programming language that wasn&rsquo;t designed with purity in mind. JavaScript&rsquo;s spec doesn&rsquo;t define &ldquo;pure function&rdquo; - we&rsquo;re borrowing an idealized mathematical concept and trying to map it onto a complex, real-world language.</p>
<p>This creates several problems:</p>
<p><strong>Equality is ambiguous.</strong> The definition requires &ldquo;identical values for identical arguments,&rdquo; but JavaScript only has referential equality built-in. Should <code>[0]</code> equal <code>[0]</code>? What about two functions that do the same thing? There&rsquo;s no universally agreed answer.</p>
<p><strong>Side effects are hard to define.</strong> Is reading a global constant a side effect? Is throwing an error? Is mutating a private property that no one else observes? The survey shows people draw the line in different places.</p>
<p><strong>The language works against us.</strong> JavaScript has surprising gotchas (like stateful regexps) and allows side effects in unexpected places (like getter methods). Pure functions exist on a spectrum from &ldquo;close to the mathematical ideal&rdquo; to &ldquo;far from it,&rdquo; but there&rsquo;s no clear threshold.</p>
<p>When someone says &ldquo;just use pure functions&rdquo; in JavaScript, they&rsquo;re really advocating for writing code that stays closer to idealized mathematical models. That&rsquo;s good advice, but the model will never perfectly match reality. Instead of treating purity as a binary property, it&rsquo;s more useful to think about <em>how</em> and <em>why</em> a function deviates from the ideal - and whether those deviations matter for your use case.</p>

</content>
<p>
  
</p>

  </main>
  <footer>Made with <a href="https://github.com/janraasch/hugo-bearblog/">Hugo ʕ•ᴥ•ʔ Bear</a>
</footer>

    
</body>

</html>
