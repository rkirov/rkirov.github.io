<!DOCTYPE html>
<html lang="en-us">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Incremental Computation (part 1) | Rado&#39;s Radical Reflections</title>
<meta name="title" content="Incremental Computation (part 1)" />
<meta name="description" content="Incremental computation is a way of performing computations, with the
expectation of future changes in the inputs to the computiation. When those
changes occur the output can be updated efficiently, at minimum faster than
redoing the whole computation from scratch.
This problem occurs in many programming domains - UI programming, data flow,
build systems, compilers, code editors. Likely you have seen it before, but
didn&rsquo;t call it incremental computation. Despite its prevalence, it is rarely
viewed as a common computational paradigm. It is more often referred to as an
ad-hoc application of caching or memoization. In comparison, other
computational paradigms like concurrent, lazy, distributed computation have
better known nomenclature and techniques." />
<meta name="keywords" content="incremental computation," />


<meta property="og:url" content="http://localhost:1313/incremental-computation-part-1/">
  <meta property="og:site_name" content="Rado&#39;s Radical Reflections">
  <meta property="og:title" content="Incremental Computation (part 1)">
  <meta property="og:description" content="Incremental computation is a way of performing computations, with the expectation of future changes in the inputs to the computiation. When those changes occur the output can be updated efficiently, at minimum faster than redoing the whole computation from scratch.
This problem occurs in many programming domains - UI programming, data flow, build systems, compilers, code editors. Likely you have seen it before, but didn’t call it incremental computation. Despite its prevalence, it is rarely viewed as a common computational paradigm. It is more often referred to as an ad-hoc application of caching or memoization. In comparison, other computational paradigms like concurrent, lazy, distributed computation have better known nomenclature and techniques.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-05-03T00:00:00+00:00">
    <meta property="article:modified_time" content="2020-05-03T00:00:00+00:00">
    <meta property="article:tag" content="Incremental Computation">




  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Incremental Computation (part 1)">
  <meta name="twitter:description" content="Incremental computation is a way of performing computations, with the expectation of future changes in the inputs to the computiation. When those changes occur the output can be updated efficiently, at minimum faster than redoing the whole computation from scratch.
This problem occurs in many programming domains - UI programming, data flow, build systems, compilers, code editors. Likely you have seen it before, but didn’t call it incremental computation. Despite its prevalence, it is rarely viewed as a common computational paradigm. It is more often referred to as an ad-hoc application of caching or memoization. In comparison, other computational paradigms like concurrent, lazy, distributed computation have better known nomenclature and techniques.">
      <meta name="twitter:site" content="@radokirov">




  <meta itemprop="name" content="Incremental Computation (part 1)">
  <meta itemprop="description" content="Incremental computation is a way of performing computations, with the expectation of future changes in the inputs to the computiation. When those changes occur the output can be updated efficiently, at minimum faster than redoing the whole computation from scratch.
This problem occurs in many programming domains - UI programming, data flow, build systems, compilers, code editors. Likely you have seen it before, but didn’t call it incremental computation. Despite its prevalence, it is rarely viewed as a common computational paradigm. It is more often referred to as an ad-hoc application of caching or memoization. In comparison, other computational paradigms like concurrent, lazy, distributed computation have better known nomenclature and techniques.">
  <meta itemprop="datePublished" content="2020-05-03T00:00:00+00:00">
  <meta itemprop="dateModified" content="2020-05-03T00:00:00+00:00">
  <meta itemprop="wordCount" content="3450">
  <meta itemprop="keywords" content="Incremental Computation">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  body {
    font-family: Verdana, sans-serif;
    margin: auto;
    padding: 20px;
    max-width: 720px;
    text-align: left;
    background-color: #fff;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: #444;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  strong,
  b {
    color: #222;
  }

  a {
    color: #3273dc;
     
  }

  .title {
    text-decoration: none;
    border: 0;
  }

  .title span {
    font-weight: 400;
  }

  nav a {
    margin-right: 10px;
  }

  textarea {
    width: 100%;
    font-size: 16px;
  }

  input {
    font-size: 16px;
  }

  content {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  img {
    max-width: 100%;
  }

  code {
    padding: 2px 5px;
    background-color: #f2f2f2;
  }

  pre code {
    color: #222;
    display: block;
    padding: 20px;
    white-space: pre-wrap;
    font-size: 14px;
    overflow-x: auto;
  }

  div.highlight pre {
    background-color: initial;
    color: initial;
  }

  div.highlight code {
    background-color: unset;
    color: unset;
  }

  blockquote {
    border-left: 1px solid #999;
    color: #222;
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px;
    text-align: center;
  }

  .helptext {
    color: #777;
    font-size: small;
  }

  .errorlist {
    color: #eba613;
    font-size: small;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: #8b6fcb;
  }

  @media (prefers-color-scheme: dark) {
    body {
      background-color: #333;
      color: #ddd;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    strong,
    b {
      color: #eee;
    }

    a {
      color: #8cc2dd;
    }

    code {
      background-color: #777;
    }

    pre code {
      color: #ddd;
    }

    blockquote {
      color: #ccc;
    }

    textarea,
    input {
      background-color: #252525;
      color: #ddd;
    }

    .helptext {
      color: #aaa;
    }
  }

</style>

</head>

<body>
  <header><a href="/" class="title">
  <h2>Rado&#39;s Radical Reflections</h2>
</a>
<nav><a href="/">Home</a>

<a href="/posts/">Blog</a>

<a href="/about/">About</a>


</nav>
</header>
  <main>

<content>
  <p>Incremental computation is a way of performing computations, with the
expectation of future changes in the inputs to the computiation. When those
changes occur the output can be updated efficiently, at minimum faster than
redoing the whole computation from scratch.</p>
<p>This problem occurs in many programming domains - UI programming, data flow,
build systems, compilers, code editors. Likely you have seen it before, but
didn&rsquo;t call it incremental computation. Despite its prevalence, it is rarely
viewed as a common computational paradigm. It is more often referred to as an
ad-hoc application of caching or memoization. In comparison, other
computational paradigms like concurrent, lazy, distributed computation have
better known nomenclature and techniques.</p>
<p>In this series of blog posts I will attempt to teach you what &lsquo;incremental
computation&rsquo; is. I will motive the problem using a small subset of JavaScript
and establish common terminology for the basic approaches to the problem.  I
spent the last few years surveying various academic and industry work that
relate to incremental computation, resulting in diverse pool of prior work.  I
hope by the end of your reading of this post that work is accessible to you.</p>
<h2 id="motivation">Motivation</h2>
<p>To introduce &lsquo;incremental computation&rsquo; I will start with intentionally limited
environment that only contains functions and immutable primitives (numbers in
this case).  Jumping straight into a full featured programming language will
obscure the core ideas. In a more formal setting this would be the lambda
calculus, but I will just use TypeScript and just stay away from higher-level
constructs like arrays. You can replace this with any run-of-the-mill
programming language that has closures.</p>
<p>Let&rsquo;s start with a very simple computation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">d</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">y</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">computation</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">d</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
</span></span></code></pre></div><p>Incremental computation, ultimately, is concerned with the question how to most
effectively re-compute <code>d(x, y)</code> when some of the inputs have changed from <code>1</code>
and <code>2</code> to something else.</p>
<p>Say the new computation I would like to execute is <code>d(1, 3)</code>. The new inputs do
not fully match the old ones, so a simple caching will not work as written.</p>
<p>However, instead of giving up on caching, I can break down the computation
down to the basic operations: addition, multiplication and square root.</p>
<p>There are four core operations performed - two multiplications, one addition
and one <code>Math.sqrt</code>. I call the basic building blocks of a computation -
operations, but note that this is not standard. To spell it out using temporary
variables:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">op2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">op3</span>);
</span></span></code></pre></div><p>Compare now with the version with the new inputs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">op2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">op3</span>);
</span></span></code></pre></div><p>For this toy example, the best incremental computation will reuse or skip <code>1 * 1</code> and then redo the other three operations with the new inputs.</p>
<p>This can be easily expressed in an abstract directed graph form. The original
computation is:</p>
<p><img src="/incr1.png" alt="Computation graph"></p>
<p>Each node represents a variable along with the computation needed to obtain in
and all incoming edges together represent the inputs to the function that
computes the variable.</p>
<p>The recomputation for <code>d(1, 3)</code> after <code>d(1, 1)</code> will ideally only go through
the path in red.</p>
<p><img src="/incr3.png" alt="Recomputation graph 1"></p>
<p>Meanwhile, the recomputation for <code>d(-1, -1)</code> after <code>d(1, 1)</code> will go start with
two red paths, but end in the middle, since <code>-1^2 == 1^2</code> the result doesn&rsquo;t
change.</p>
<p><img src="/incr4.png" alt="Recomputation graph 2"></p>
<p>The basic algorithm of incremental computation over the abstract computation
graph is:</p>
<p><strong>Basic Algorithm of Incremental Computation</strong></p>
<ol>
<li>when at least one of the inputs of an operation has changed, redo the
operation to get new outputs.</li>
<li>repeat until there are no more changes.</li>
</ol>
<p>This algorithm is so simple that it has no name. The complexity comes in how to
best build the computation graph, especially on top of general programming
languages which have no incremental primitives.</p>
<p>The key questions around incremental computation at the abstract level of the
computation graph will be:</p>
<ul>
<li>how is this computation graph built?</li>
<li>how is the graph traversed. The Basic Algorithm in intentionally vague around that.</li>
<li>can it change while the program is running?</li>
<li>what if it has cycles?</li>
</ul>
<p>The questions that I view secondary to the core and not going to explore at detail:</p>
<ul>
<li>who does the recomputation</li>
<li>where is the data stored</li>
<li>can it be parallelized across different processes</li>
</ul>
<h2 id="memoization">Memoization</h2>
<p>At this simple form incremental computation seems to be connected to
function memoization. Memoization is comparing the inputs of a function against
a cache of (inputs, output) pairs. If seen, the function body is skipped and
output used, otherwise the function body executes and the output is stored in
the cache.</p>
<p>Incremental computation usually is concerned with the recomputation against a
single past result, which would make it most fitting to use memoization with
a cache size of one. I view basic caching considerations - like size of cache,
least-frequently-used vs other strategies, orthogonal to the core problems
of incremental computation.</p>
<p>In order to apply memoization to the computatation above, we have to first
rewrite the function to separate the basic operations. This is known as
<a href="https://en.wikipedia.org/wiki/A-normal_form">A-normal form</a> in the compiler
literature.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">d</span>(<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">number</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">number</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">y</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">op2</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">op3</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">op4</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now, we can memoize each inner operation along with the whole function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">memoAdd</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>(<span style="color:#a6e22e">add</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">memoSquare</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>(<span style="color:#a6e22e">square</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">memoSqrt</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>(Math.<span style="color:#a6e22e">sqrt</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">innerMemoD</span>(<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">number</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">number</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">y</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoAdd</span>(<span style="color:#a6e22e">op1</span>, <span style="color:#a6e22e">op2</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoSqrt</span>(<span style="color:#a6e22e">op3</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">op4</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">memoD</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>(<span style="color:#a6e22e">innerMemoD</span>);
</span></span></code></pre></div><p>This is admittedly, much more efficient and but I claim it is not the end of
the story for incremental computation. Notice that while each operation is
memoized - the computation proceeds exactly the same way as before through the computation graph:</p>
<p><img src="/incr5.png" alt="Computation Graph"></p>
<p>We made the cost of each operation as small as possible during the evaluation,
but the flow is always the same.</p>
<h2 id="beyond-memoization">Beyond memoization</h2>
<p>Let&rsquo;s try to change the computation graph flow during recomputation. We can
start by manually adding some &lsquo;skip to the end&rsquo; calls:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastOp1</span>: <span style="color:#66d9ef">null</span><span style="color:#f92672">|</span><span style="color:#66d9ef">number</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastOp2</span>: <span style="color:#66d9ef">null</span><span style="color:#f92672">|</span><span style="color:#66d9ef">number</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastOp3</span>: <span style="color:#66d9ef">null</span><span style="color:#f92672">|</span><span style="color:#66d9ef">number</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastOp4</span>: <span style="color:#66d9ef">null</span><span style="color:#f92672">|</span><span style="color:#66d9ef">number</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">skipCallsD</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// why not &#39;if op === lastOp1 -&gt; skip&#39; here?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">y</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">op1</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">lastOp1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">lastOp2</span>) <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">lastOp4</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">lastOp1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op1</span>; <span style="color:#a6e22e">lastOp2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoAdd</span>(<span style="color:#a6e22e">op1</span>, <span style="color:#a6e22e">op2</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">op3</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">lastOp3</span>) <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">lastOp4</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">lastOp3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op3</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoSqrt</span>(<span style="color:#a6e22e">op3</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">lastOp4</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op4</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">op4</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice that the structure of the checks matches the abstract computation graph.
We can&rsquo;t skip to the end if <code>op1</code> hasn&rsquo;t changed, because potentially <code>op2</code> can
be different.</p>
<p>This implementation allows us to achieve the incremental flow depicted here for
recomputing <code>d(-1,-1)</code> after <code>d(1, 1)</code></p>
<p><img src="/incr4.png" alt="Recomputation graph 2"></p>
<p>But will not as written help with recomputing <code>d(1, 3)</code> after <code>d(1, 1)</code>.</p>
<p><img src="/incr3.png" alt="Recomputation graph 1"></p>
<p>You should begin to see how to achieve &ldquo;full incrementality&rdquo; in the computation
graph model. At each node if all inputs are unchanged we can skip until the
next multi-input node or end of the computation if there are none. This is
simply a restatement of the basic algorithm using the observation that a single
input computation chain can be skipped to its end upon the first repeated
output.</p>
<p>To make the example above fully incremental requires adding <code>lastX</code> and <code>lastY</code>
and the following checks (at the right places):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">lastX</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">lastY</span>) <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">lastOp4</span>;  <span style="color:#75715e">// memoization condition
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">op1</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">lastOp1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">lastY</span>) <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">lastOp4</span>;
</span></span></code></pre></div><p>Notice how much has our simple one-line function <code>d</code> has grown in size to
achieve incrementality. Also unlike memoization it is not clear how precisely
to mechanically add the if-else checks.</p>
<p>Next we will try to change the shape of the code. As it turns out the direct
style of computation only one amongst many different ways for computation to
look like. For each of those we will add incrementality. The hope is that the
reshaping makes it easier to add incrementality.</p>
<h2 id="direct-versus-reversed-computation">Direct versus Reversed Computation</h2>
<p>The program we have had so far was written in direct style. Each operation is
done in order <code>op1</code>,<code>op2</code>,<code>op3</code>,<code>op4</code> and each reads the variables it needs.</p>
<p>We can reverse the computation flow by imagining starting with <code>op4</code>, which
in turn would need to compute <code>op3</code> which will need <code>op1</code> and <code>op2</code>. At the
end we have <code>x</code> and <code>y</code> which are inputs to the computation.</p>
<p>Giving simple wrapper classes around these concepts - <code>Input</code>, <code>SingleInputCmp</code>
and <code>DoubleInputCmp</code>, the computation can look something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#75715e">// computation description
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Input</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Input</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SingleInputCmp</span>(<span style="color:#a6e22e">square</span>, <span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SingleInputCmp</span>(<span style="color:#a6e22e">square</span>, <span style="color:#a6e22e">y</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">DoubleInputCmp</span>(<span style="color:#a6e22e">add</span>, <span style="color:#a6e22e">op1</span>, <span style="color:#a6e22e">op2</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SingleInputCmp</span>(Math.<span style="color:#a6e22e">sqrt</span>, <span style="color:#a6e22e">op3</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// computation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">op4</span>.<span style="color:#66d9ef">get</span>();
</span></span></code></pre></div><p>The arguments to each <code>*Cmp</code> class are pure functions to do the operation
(like <code>square</code> or <code>add</code>) and one or two inputs depending on what is needed for
the operation. The interesting part is that now the computation is described in
code first and only afterwards &ldquo;executed&rdquo; in a reversed &ldquo;output-to-input&rdquo;
fashion.</p>
<p>The rest of the code can be simply implemented like (apologies for folks
that prefer not to use classes in TypeScript):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Var</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">get</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Input</span> <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">Var</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">constructor</span>(<span style="color:#66d9ef">private</span> <span style="color:#a6e22e">val</span>: <span style="color:#66d9ef">number</span>) {}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">set</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">val</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">get</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">val</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SingleInputCmp</span> <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">Var</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">constructor</span>(<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">cmp</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>,
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">input</span>: <span style="color:#66d9ef">Var</span>) {}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">get</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">input</span>.<span style="color:#66d9ef">get</span>());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DoubleInputCmp</span> <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">Var</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">constructor</span>(<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">cmp</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>,
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">input1</span>: <span style="color:#66d9ef">Var</span>,
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">input2</span>: <span style="color:#66d9ef">Var</span>) {}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">get</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">number</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">input1</span>.<span style="color:#66d9ef">get</span>(), <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">input2</span>.<span style="color:#66d9ef">get</span>());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So we reshaped the computation, but did it make it easier to add
incrementality?  As it turns out the answer is &rsquo;no&rsquo;. If we notice that <code>op1</code>
and <code>op2</code> are the same and want to jump to the old output that would require
skipping over <code>op3</code> which was on the function call stack. We have to keep a
custom stack in order to achieve this, so I will leave this as an exercise to
the reader. You can see a gist to my solution (here)[https://gist.github.com/rkirov/1e002748a9794b098f39c918d191f59b].</p>
<p>Next we will look at another classic transformation of the computation model -
<a href="https://en.wikipedia.org/wiki/Continuation-passing_style">continuation passing style</a>.</p>
<h2 id="incremental-computation-and-continuation-passing-style">Incremental Computation and Continuation Passing Style</h2>
<p>If you have never seen it before, it can be explained with a bit of insight
from the lambda calculus on top of our previous rewriting into basic operations
(the A-normal form). Each variable assignment <code>let x = &lt;init&gt;; &lt;rest&gt;</code> can be
written as <code>((x) =&gt; &lt;rest&gt;)(&lt;init&gt;)</code>. The <code>(x) =&gt; &lt;rest&gt;</code> function is called
<strong>the continuation</strong>. In a slight modification from traditional CSP transform
where the continuation is further passed into all other functions, we will skip
that part.</p>
<p>We will do this transformation step-by-step:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">cspD</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> ((<span style="color:#a6e22e">op1</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> 
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>  )(<span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">x</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>then add <code>op2</code>,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">cspD</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> ((<span style="color:#a6e22e">op1</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> 
</span></span><span style="display:flex;"><span>    ((<span style="color:#a6e22e">op2</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span>
</span></span><span style="display:flex;"><span>      ...
</span></span><span style="display:flex;"><span>    )(<span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">y</span>))
</span></span><span style="display:flex;"><span>  )(<span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">x</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and eventually get to</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">cspD</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> ((<span style="color:#a6e22e">op1</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> 
</span></span><span style="display:flex;"><span>    ((<span style="color:#a6e22e">op2</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span>
</span></span><span style="display:flex;"><span>      ((<span style="color:#a6e22e">op3</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span>
</span></span><span style="display:flex;"><span>        ((<span style="color:#a6e22e">op4</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">op4</span> 
</span></span><span style="display:flex;"><span>        )(Math.<span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">op3</span>))
</span></span><span style="display:flex;"><span>      )(<span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">op1</span>, <span style="color:#a6e22e">op2</span>))
</span></span><span style="display:flex;"><span>    )(<span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">y</span>))
</span></span><span style="display:flex;"><span>  )(<span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">x</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now let&rsquo;s try to add incrementality. Given than we see a four new functions
imagine memoizing them.</p>
<p>While it will give us the correct recomputation of <code>d(-1,-1)</code> after <code>d(1,1)</code> it
will be wrong for <code>d(1, 3)</code> after <code>d(1, 1)</code>. This is because as soon as <code>op1</code>
is the same as before we will skip to the end, ignoring any change to <code>op2</code>.</p>
<p>The correct rewriting for memoization requires to preserve the fact <code>op3</code> has
two inputs over which we have to memoize together. This looks like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">insideOutD</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> ((<span style="color:#a6e22e">op1</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">op2</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> 
</span></span><span style="display:flex;"><span>    ((<span style="color:#a6e22e">op3</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span>
</span></span><span style="display:flex;"><span>      ((<span style="color:#a6e22e">op4</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">op4</span> 
</span></span><span style="display:flex;"><span>      )(<span style="color:#a6e22e">memoSqrt</span>(<span style="color:#a6e22e">op3</span>))
</span></span><span style="display:flex;"><span>    )(<span style="color:#a6e22e">memoAdd</span>(<span style="color:#a6e22e">op1</span>, <span style="color:#a6e22e">op2</span>))
</span></span><span style="display:flex;"><span>  )(<span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">x</span>), <span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">y</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally, we can extract the functions to run them through the memoization operation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fn1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>((<span style="color:#a6e22e">op1</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">op2</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">fn2</span>(<span style="color:#a6e22e">memoAdd</span>(<span style="color:#a6e22e">op1</span>, <span style="color:#a6e22e">op2</span>)));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fn2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>((<span style="color:#a6e22e">op3</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">fn3</span>(<span style="color:#a6e22e">memoSqrt</span>(<span style="color:#a6e22e">op3</span>)));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fn3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>((<span style="color:#a6e22e">op4</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">op4</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">superMemoDInner</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fn1</span>(<span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">x</span>), <span style="color:#a6e22e">memoSquare</span>(<span style="color:#a6e22e">y</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">superMemoD</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memo</span>(<span style="color:#a6e22e">superMemoD</span>, <span style="color:#e6db74">&#39;d&#39;</span>);
</span></span></code></pre></div><p>While requiring a fancy program rewriting, to the point where the original
program is unrecognizable, this has a more aesthetically pleasing property that
one can begin to imagine a principled way of adding incrementality instead of
manually inserting if-else statements.</p>
<p>Also having so many memoization calls is certainly an overkill in any practical
problem &ndash; we are memoizing an identity function at some point! &ndash; but the
point of pushing a simple example to the extreme is to see all the
opportunities for incrementality.</p>
<p>However, notice that we still have the same problem as the example with manual
<code>if-else</code> statements, we do not have incrementality for this flow:</p>
<p><img src="/incr3.png" alt="Recomputation graph 1"></p>
<p>While we can &ldquo;skip to the end&rdquo; of the computation, we cannot skip over the
purely <code>x</code> part of the computation graph, if we know <code>x</code> hasn&rsquo;t changed.</p>
<p>It is likely achievable with more fancy program rewriting, we will get
there by using a different technique - push-based incremental computation.</p>
<h2 id="push-vs-pull-in-incremental-computation">Push vs Pull in Incremental Computation</h2>
<p>In the computations we have seen so far the numbers were either directly read
through variables <code>x</code>, <code>op1</code>, or we used a <code>.get(): number</code> method. These
are examples of <strong>pull</strong>-based computation, because the code that needs to do
something with the numbers pulls them.</p>
<p>There is a dual approach known as <em>push-based</em> computation, because the new
values of inputs, push themselves into the computation. A telltale sign of
push-based computation is where in the type signature does the core computation
type <code>T</code> appear:</p>
<ul>
<li>pull - the methods look like <code>(...): T</code>.</li>
<li>push - the methods looks like <code>((x: T) =&gt; ...): ...</code>.</li>
</ul>
<p>Another terminology used is reactive vs interactive, but there is something called
&lsquo;push-based reactivity&rsquo; so I am going to steer clear of these to avoid confusion.</p>
<p>In our original example, a push-based version will look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#75715e">// description
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Input</span>((<span style="color:#a6e22e">o</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">op1</span>.<span style="color:#66d9ef">set</span>(<span style="color:#a6e22e">o</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Input</span>((<span style="color:#a6e22e">o</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">op2</span>.<span style="color:#66d9ef">set</span>(<span style="color:#a6e22e">o</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SingleInputCmp</span>(<span style="color:#a6e22e">square</span>, (<span style="color:#a6e22e">o</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">op3</span>.<span style="color:#a6e22e">set1</span>(<span style="color:#a6e22e">o</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SingleInputCmp</span>(<span style="color:#a6e22e">square</span>, (<span style="color:#a6e22e">o</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">op3</span>.<span style="color:#a6e22e">set2</span>(<span style="color:#a6e22e">o</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">DoubleInputCmp</span>(<span style="color:#a6e22e">add</span>, (<span style="color:#a6e22e">o</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">op4</span>.<span style="color:#66d9ef">set</span>(<span style="color:#a6e22e">o</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SingleInputCmp</span>(Math.<span style="color:#a6e22e">sqrt</span>, (<span style="color:#a6e22e">o</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`new output </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">o</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// computation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">x</span>.<span style="color:#66d9ef">set</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">y</span>.<span style="color:#66d9ef">set</span>(<span style="color:#ae81ff">1</span>);
</span></span></code></pre></div><p>Notice the key difference is that each object is created with a callback that tells it
whom to notify upon a change in output. Also the direction of the computation is direct
as it progresses from inputs towards outputs.</p>
<p>Writing the underlying classes is relatively straight forward:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Input</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">constructor</span>(<span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">set</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>) {}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SingleInputCmp</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">constructor</span>(<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">cmp</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>,
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">update</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>) {}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">set</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">cmp</span>(<span style="color:#a6e22e">x</span>));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>until we get to the <code>DoubleInputCmp</code> which is required to store some state
as the two input updates can arrive at different times.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DoubleInputCmp</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">lastArg1?</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">lastArg2?</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">constructor</span>(<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">cmp</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>,
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">update</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>) {}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">set1</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastArg2</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">cmp</span>(<span style="color:#a6e22e">x</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastArg2</span>));
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastArg1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">set2</span>(<span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastArg1</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastArg1</span>, <span style="color:#a6e22e">y</span>)); 
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastArg2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>But once we started adding tracking of state inside the computation nodes, we are
basically one step away from incrementality. It will look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Input</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">lastValue?</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">constructor</span>(<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">update</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>) {}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">set</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastValue</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">update</span>(<span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SingleInputCmp</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">lastValue?</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">constructor</span>(<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">cmp</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>,
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">update</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>) {}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">set</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastValue</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">newVal</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">cmp</span>(<span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">update</span>(<span style="color:#a6e22e">newVal</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">newVal</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DoubleInputCmp</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">lastValue1?</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">lastValue2?</span>: <span style="color:#66d9ef">number</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">constructor</span>(<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">cmp</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">number</span>,
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#a6e22e">update</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">void</span>) {}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">set1</span>(<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastValue1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastValue2</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">undefined</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">newVal</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">cmp</span>(<span style="color:#a6e22e">x</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastValue2</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">update</span>(<span style="color:#a6e22e">newVal</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastValue1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">set2</span>(<span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">y</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastValue2</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastValue1</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">undefined</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">newVal</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastValue1</span>, <span style="color:#a6e22e">y</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">update</span>(<span style="color:#a6e22e">newVal</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastValue2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now a recomputation will look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#a6e22e">y</span>.<span style="color:#66d9ef">set</span>(<span style="color:#ae81ff">3</span>); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 3.1622776601683795 logged
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">y</span>.<span style="color:#66d9ef">set</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1.4142135623730951 logged
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">y</span>.<span style="color:#66d9ef">set</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// nothing logged, no change.
</span></span></span></code></pre></div><p>And by the magic of update callbacks and lastValue checks the computation does
the minimum needed work. The downside of this approach is that batch updates,
meaning change a number of inputs and then recompute are harder to implement.</p>
<p>Push-based computations appears naturally easier for incrementality. The same
observation was made by Yaron Minksy in his excellent blog on the Incremental
library in OCaml
<a href="https://blog.janestreet.com/introducing-incremental/">https://blog.janestreet.com/introducing-incremental/.</a></p>
<p>If you are wondering if there is such thing as a reversed push-based
computation, that&rsquo;s another thing I am leaving to the reader. Spoiler it
doesn&rsquo;t appear to be nicer than the direct push-based style.</p>
<h2 id="connection-with-reactive--streaming-frameworks">Connection with Reactive / Streaming frameworks</h2>
<p>If you are familiar with reactive primitives like - streams, observables, etc,
you might have observed that the &lsquo;push-based&rsquo; code is starting to look like
one. That is absolutely correct, here is the same computation,
using rxjs observables.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> {<span style="color:#66d9ef">of</span>, <span style="color:#a6e22e">combineLatest</span>, <span style="color:#a6e22e">Subject</span>} <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;rxjs&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">map</span>, <span style="color:#a6e22e">distinctUntilChanged</span>} <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;rxjs/operators&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Subject</span>&lt;<span style="color:#f92672">number</span>&gt;();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Subject</span>&lt;<span style="color:#f92672">number</span>&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">square</span>), <span style="color:#a6e22e">distinctUntilChanged</span>());
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">square</span>), <span style="color:#a6e22e">distinctUntilChanged</span>());
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">combineLatest</span>(<span style="color:#a6e22e">op1</span>, <span style="color:#a6e22e">op2</span>).<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">map</span>(([<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>]) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)),
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">distinctUntilChanged</span>()); 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">op4</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">op3</span>.<span style="color:#a6e22e">pipe</span>(<span style="color:#a6e22e">map</span>(Math.<span style="color:#a6e22e">sqrt</span>), <span style="color:#a6e22e">distinctUntilChanged</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">op4</span>.<span style="color:#a6e22e">subscribe</span>(<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;initial computation&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;re-computation of with new y&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">next</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;re-computation of with new x&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">3</span>);
</span></span></code></pre></div><p>So is incremental computation the same as reactive programming? The way I see
it reactive programming with streams can solve many problems of which
incremental computation is just one of. As we shall see as we go along
incremental computation does not need the full power of Rxjs reactive
primitives.</p>
<h2 id="build-systems-and-incremental-computation">Build systems and incremental computation</h2>
<p>Build systems are tools that perform incremental computation specifically in
the domain of files and executables that read and write these files.  If you
familiar with build systems like &lsquo;make&rsquo;, &rsquo;ninja&rsquo; or &lsquo;bazel&rsquo;, you might have
already spotted the similarities with what we have been discussing so far.</p>
<p>The major different is the domain of build tools is more limited than
general computation, and usually they have DSL for describing the computation
that is different from a general purpose programming language.</p>
<p>Our simple computation will look like this in Make. If you never seen a
Makefile before you read it as <code>&lt;output filename&gt;: &lt;input files&gt;\n\t&lt;bash command to run&gt;</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-make" data-lang="make"><span style="display:flex;"><span><span style="color:#a6e22e">op1</span><span style="color:#f92672">:</span> x
</span></span><span style="display:flex;"><span>	node square.js x &gt; op1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">op2</span><span style="color:#f92672">:</span> y
</span></span><span style="display:flex;"><span>	node square.js y &gt; op2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">op3</span><span style="color:#f92672">:</span> op1 op2
</span></span><span style="display:flex;"><span>	node add.js op1 op2 &gt; op3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">op4</span><span style="color:#f92672">:</span> op3
</span></span><span style="display:flex;"><span>	node sqrt.js op3 &gt; op4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">d</span><span style="color:#f92672">:</span> op4
</span></span><span style="display:flex;"><span>	cat op4
</span></span></code></pre></div><p>The scripts <code>square.js</code>, <code>add.js</code>, <code>sqrt.js</code> are straight-forward
implementation that read the files, parse them as numbers and print the
operation in the name.</p>
<pre tabindex="0"><code>// computation
$ echo 1 &gt; x; echo 1 &gt; y;
$ make d
node square.js x &gt; op1
node square.js y &gt; op2
node add.js op1 op2 &gt; op3
node sqrt.js op3 &gt; op4
cat op4
1.4142135623730951

// recomputation
$ echo 3 &gt; y;
$ make d
node square.js y &gt; op2
node add.js op1 op2 &gt; op3
node sqrt.js op3 &gt; op4
cat op4
3.1622776601683795
</code></pre><p>As <code>make</code> prints out the operations it performs, it is clear that <code>op1</code> is skipped
when its inputs have not changed. It is worth mentioning that build systems
usually use file timestamps as check whether something has changed or not,
which can result in less incrementality when using inputs like <code>-1</code> that are
equivalent to <code>1</code> after squaring.</p>
<p>In terms of the characteristics we described earlier, <code>make</code> looks like a
reverse pull-based computation. We start with the final output <code>op4</code> (reverse)
and each file is directly read (pull-based) instead of using a file watch
mechanism for each file to pass it contents into the next operation.</p>
<p>Since, build systems are most successful implementations of incremental
computations, one can say that incremental computation is a way of turning your
general programs into small build systems.</p>
<h2 id="onto-part-2">Onto part 2</h2>
<p>The next challenge is to extend the toy computation model to a full blown
language that includes control flow and mutable object. We will begin with
control flow.</p>
<p><a href="/posts/incremental_computation_2">Continue to part 2 of the post</a></p>

</content>
<p>
  
  <a href="http://localhost:1313/posts/incremental-computation/">#Incremental Computation</a>
  
</p>

  </main>
  <footer>Made with <a href="https://github.com/janraasch/hugo-bearblog/">Hugo ʕ•ᴥ•ʔ Bear</a>
</footer>

    
</body>

</html>
