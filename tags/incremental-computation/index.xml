<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>incremental computation on Subtly Different Semantics</title>
    <link>https://rkirov.github.io/tags/incremental-computation/</link>
    <description>Recent content in incremental computation on Subtly Different Semantics</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 19 May 2020 00:00:00 -0700</lastBuildDate>
    
	<atom:link href="https://rkirov.github.io/tags/incremental-computation/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Incremental Computation (Draft of part 3)</title>
      <link>https://rkirov.github.io/posts/incremental_computation_3/</link>
      <pubDate>Tue, 19 May 2020 00:00:00 -0700</pubDate>
      
      <guid>https://rkirov.github.io/posts/incremental_computation_3/</guid>
      <description>Why TypeScript? Maybe you wondering why are we even doing this in TypeScript. As it happens I have been working in the frond-end community in the last 8 years. My interest in incremental computation started by observing the similiarities betwen some of the work I have done inside Angular&amp;rsquo;s &amp;ldquo;change detection&amp;rdquo; algorithms, and work I have done around integrating TypeScript&amp;rsquo;s compiler in Google&amp;rsquo;s build systems.
UI programming Why is incremental computation naturally appearing in UIs?</description>
    </item>
    
    <item>
      <title>Incremental Computation (Draft of part 2)</title>
      <link>https://rkirov.github.io/posts/incremental_computation_2/</link>
      <pubDate>Sun, 10 May 2020 00:00:00 -0700</pubDate>
      
      <guid>https://rkirov.github.io/posts/incremental_computation_2/</guid>
      <description>Incremental computation (part 2) We have been talking about general computation, but so far our language was very limited. We only used function calls, numbers, and simple variable binding.
We will slowly add more language primitives and see how to still have incrementality of the computation. First is conditional statements.
Conditional statements Let&amp;rsquo;s add a single conditional statement first.
function cond(b: boolean, x: number, y: number) { return b ? x * x : y * y; } What does it mean to make cond incremental?</description>
    </item>
    
    <item>
      <title>Incremental Computation (Draft of part 1)</title>
      <link>https://rkirov.github.io/posts/incremental_computation/</link>
      <pubDate>Sun, 03 May 2020 00:00:00 -0700</pubDate>
      
      <guid>https://rkirov.github.io/posts/incremental_computation/</guid>
      <description>Incremental computation is a way of performing computations, with the expectation of future changes in inputs. When those changes occur the new output can be obtained efficiently, at minimum avoiding redoing the whole computation.
Many programming environments deal with this problem - UI programming, dataflow, build systems, etc. Despite its prevalence, I find it is rarely viewer as a unified computational paradigm, as opposed to ad-hoc application of caching. In comparison, other computational paradigms like concurrent or distributed computating have better established nomenclature and techniques.</description>
    </item>
    
  </channel>
</rss>