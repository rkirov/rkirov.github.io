<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rado&#39;s Radical Reflections</title>
    <link>https://rkirov.github.io/</link>
    <description>Recent content on Rado&#39;s Radical Reflections</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <managingEditor>rkirov@gmail.com</managingEditor>
    <webMaster>rkirov@gmail.com</webMaster>
    <lastBuildDate>Tue, 11 Feb 2025 22:26:55 -0800</lastBuildDate>
    <atom:link href="https://rkirov.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Learning Lean: Part 1</title>
      <link>https://rkirov.github.io/posts/lean1/</link>
      <pubDate>Tue, 11 Feb 2025 22:26:55 -0800</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/lean1/</guid>
      <description>&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;&#xA;&lt;p&gt;I&amp;rsquo;ve been captivated by the recent movement to popularize mathematics formalization through the LEAN theorem prover, and this year I&amp;rsquo;m diving deeper into learning it.&lt;/p&gt;&#xA;&lt;p&gt;For those unfamiliar with this revolution, I highly recommend watching &lt;a href=&#34;https://www.youtube.com/watch?v=SEID4XYFN7o&amp;amp;ab_channel=InternationalMathematicalUnion&#34;&gt;Kevin Buzzard&amp;rsquo;s talks on YouTube&lt;/a&gt; for an overview of why formal mathematics is generating such excitement in the mathematical community.&lt;/p&gt;&#xA;&lt;p&gt;The immediate benefits of formalization are well-documented: it helps catch errors in proofs and reduces the need for trust between collaborators since every step is mechanically verified. However, I believe there&amp;rsquo;s another compelling advantage that&amp;rsquo;s less frequently discussed: formalization enables a better separation of concerns in mathematical writing.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ticket to Ride: First Journey simulation authored with AI</title>
      <link>https://rkirov.github.io/posts/ticket/</link>
      <pubDate>Sat, 18 Jan 2025 11:52:17 -0800</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/ticket/</guid>
      <description>&lt;h2 id=&#34;ticket-to-ride-first-journey-simulation-authored-with-ai&#34;&gt;Ticket to Ride: First Journey simulation authored with AI&lt;/h2&gt;&#xA;&lt;p&gt;After playing &lt;a href=&#34;https://www.daysofwonder.com/ticket-to-ride/kids/first-journey/&#34;&gt;Ticket to Ride: First Journey&lt;/a&gt;&#xA;with my family recently, I got the urge&#xA;to analyze some statistical properties of the game.&#xA;This seemed like an excellent opportunity to experiment with Cursor AI and explore more automated approaches to coding. Here&amp;rsquo;s what I discovered.&lt;/p&gt;&#xA;&lt;h2 id=&#34;results&#34;&gt;Results&lt;/h2&gt;&#xA;&lt;p&gt;After a couple of hours the AI and I produced the following analyses:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;The 32 tickets in the game can be categorized by their optimal paths:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Puzzles2024</title>
      <link>https://rkirov.github.io/posts/puzzles2024/</link>
      <pubDate>Tue, 31 Dec 2024 11:42:13 -0800</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/puzzles2024/</guid>
      <description>&lt;h1 id=&#34;puzzle-games-of-2024&#34;&gt;Puzzle games of 2024&lt;/h1&gt;&#xA;&lt;p&gt;As the year draws to a close, I want to share my favorite puzzle games from 2024. This isn&amp;rsquo;t meant to be an exhaustive review or ranking of all puzzle games released this year, but rather a personal reflection on the games that captured my attention. If you&amp;rsquo;re new to the puzzle genre, I recommend starting with the &lt;a href=&#34;https://thinkygames.com/games/?query=&amp;amp;released=true&amp;amp;essential=true&amp;amp;sortBy=-releaseDate&#34;&gt;essential thinky games list&lt;/a&gt; - all of those titles are excellent.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Aoc2024</title>
      <link>https://rkirov.github.io/posts/aoc2024/</link>
      <pubDate>Wed, 25 Dec 2024 21:40:07 -0800</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/aoc2024/</guid>
      <description>&lt;h1 id=&#34;advent-of-code-2024-retro&#34;&gt;Advent of Code 2024 Retro&lt;/h1&gt;&#xA;&lt;p&gt;Advent of Code &lt;a href=&#34;https://adventofcode.com/&#34;&gt;AoC&lt;/a&gt; is an annual programming&#xA;competition that releases daily coding puzzles throughout December. For the past&#xA;four years, I&amp;rsquo;ve tackled these challenges from the West Coast, where the 9 PM&#xA;PST release time perfectly suits my schedule. While I compete for points on the&#xA;global leaderboard (with modest success), the real joy comes from the community&#xA;around it. Through Stripe&amp;rsquo;s solution-sharing Slack group, and the active&#xA;&lt;a href=&#34;https://www.reddit.com/r/adventofcode/&#34;&gt;r/adventofcode&lt;/a&gt; community, discussing&#xA;creative approaches to challenging problems adds an new dimension to my favorite&#xA;pastime - solving puzzles.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Incremental Computation (part 3)</title>
      <link>https://rkirov.github.io/posts/incremental_computation_3/</link>
      <pubDate>Tue, 19 May 2020 00:00:00 +0000</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/incremental_computation_3/</guid>
      <description>&lt;h2 id=&#34;why-typescript&#34;&gt;Why TypeScript?&lt;/h2&gt;&#xA;&lt;p&gt;Maybe you wondering why did I use TypeScript for this post. As it happens I&#xA;have been working in the frond-end community in the last 8 years. My interest&#xA;in incremental computation started by observing the similarities between some&#xA;of the work I have done inside Angular&amp;rsquo;s &amp;ldquo;change detection&amp;rdquo; algorithms, and&#xA;work I have done around integrating TypeScript&amp;rsquo;s compiler in &lt;a href=&#34;https://bazel.build/&#34;&gt;Google&amp;rsquo;s build&#xA;system&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;ui-programming&#34;&gt;UI programming&lt;/h2&gt;&#xA;&lt;p&gt;Why is incremental computation naturally appearing in UIs? As the user is&#xA;interacting with an UI they are providing new inputs. Usually, these inputs are&#xA;small compared with the initial input to the UI. On the other side the&#xA;producing the DOM is the quintessential &amp;ldquo;expensive&amp;rdquo; computation. If it redone&#xA;on each user input the UI will be unusable. So all UI frameworks attempt to&#xA;solve the incremental computation problem, struggling with the fact that JS has&#xA;no support for incremental computation. To make matters worse as we have seen&#xA;incrementality is easier in a functional language, but JS is not well suited to&#xA;that paradigm (which doesn&amp;rsquo;t stop people from trying).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Incremental Computation (part 2)</title>
      <link>https://rkirov.github.io/posts/incremental_computation_2/</link>
      <pubDate>Sun, 10 May 2020 00:00:00 +0000</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/incremental_computation_2/</guid>
      <description>&lt;p&gt;We have been talking about general computation, but so far our language was&#xA;very limited. We only used function calls, numbers, and simple variable&#xA;binding.&lt;/p&gt;&#xA;&lt;p&gt;We will slowly add more language primitives and see how to still have&#xA;full incrementality of the computation.&lt;/p&gt;&#xA;&lt;h2 id=&#34;conditional-statements&#34;&gt;Conditional statements&lt;/h2&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s add a single conditional statement first.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cond&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;number&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; : &lt;span style=&#34;color:#66d9ef&#34;&gt;y&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;What does it mean to make &lt;code&gt;cond&lt;/code&gt; incremental? Say&#xA;we compute the result first for some values of&#xA;&lt;code&gt;b&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Incremental Computation (part 1)</title>
      <link>https://rkirov.github.io/posts/incremental_computation/</link>
      <pubDate>Sun, 03 May 2020 00:00:00 +0000</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/posts/incremental_computation/</guid>
      <description>&lt;p&gt;Incremental computation is a way of performing computations, with the&#xA;expectation of future changes in the inputs to the computiation. When those&#xA;changes occur the output can be updated efficiently, at minimum faster than&#xA;redoing the whole computation from scratch.&lt;/p&gt;&#xA;&lt;p&gt;This problem occurs in many programming domains - UI programming, data flow,&#xA;build systems, compilers, code editors. Likely you have seen it before, but&#xA;didn&amp;rsquo;t call it incremental computation. Despite its prevalence, it is rarely&#xA;viewed as a common computational paradigm. It is more often referred to as an&#xA;ad-hoc application of caching or memoization. In comparison, other&#xA;computational paradigms like concurrent, lazy, distributed computation have&#xA;better known nomenclature and techniques.&lt;/p&gt;</description>
    </item>
    <item>
      <title>About</title>
      <link>https://rkirov.github.io/about/</link>
      <pubDate>Sun, 26 Apr 2020 23:05:21 -0700</pubDate><author>rkirov@gmail.com</author>
      <guid>https://rkirov.github.io/about/</guid>
      <description>&lt;p&gt;Hello! I&amp;rsquo;m Rado Kirov, a front-end engineer at Stripe where I maintain &lt;a href=&#34;https://docs.stripe.com/js&#34;&gt;stripe.js&lt;/a&gt;. Before this, I worked at Google on front-end infrastructure, helping build core technologies like Angular, TypeScript tooling, and the Closure Compiler. I started my career in academia as a mathematician, completing a postdoc before transitioning to software engineering.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
